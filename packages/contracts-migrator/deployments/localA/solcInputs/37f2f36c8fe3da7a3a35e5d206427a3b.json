{
  "language": "Solidity",
  "sources": {
    "src/ArchanovaAccount.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Archanova account\n *\n * @author Stanisław Głogowski <stan@pillarproject.io>\n */\nabstract contract ArchanovaAccount {\n  struct Device {\n    bool isOwner;\n    bool exists;\n    bool existed;\n  }\n\n  mapping(address => Device) public devices;\n\n  // events\n\n  event DeviceAdded(\n    address device,\n    bool isOwner\n  );\n\n  event DeviceRemoved(\n    address device\n  );\n\n  event TransactionExecuted(\n    address recipient,\n    uint256 value,\n    bytes data,\n    bytes response\n  );\n\n  // external functions\n\n  function addDevice(\n    address device,\n    bool isOwner\n  )\n    virtual\n    external;\n\n  function removeDevice(\n    address device\n  )\n    virtual\n    external;\n\n  function executeTransaction(\n    address payable recipient,\n    uint256 value,\n    bytes calldata data\n  )\n    virtual\n    external\n    returns (bytes memory);\n}\n"
    },
    "src/ArchanovaMigrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"@etherspot/contracts/src/common/libs/ECDSALib.sol\";\nimport \"@etherspot/contracts/src/common/lifecycle/Initializable.sol\";\nimport \"@etherspot/contracts/src/common/token/ERC20Token.sol\";\nimport \"@etherspot/contracts/src/ens/ENSController.sol\";\nimport \"@etherspot/contracts/src/ens/ENSRegistry.sol\";\nimport \"./ArchanovaAccount.sol\";\n\n\n/**\n * @title Archanova migrator\n *\n * @author Stanisław Głogowski <stan@pillarproject.io>\n */\ncontract ArchanovaMigrator is Initializable {\n  using ECDSALib for bytes32;\n\n  bytes32 constant private MIGRATION_MESSAGE_PREFIX = keccak256(abi.encodePacked(\"etherspot <> archanova migration\"));\n  bytes4 constant private ENS_CONTROLLER_SET_ADDR_SELECTOR = bytes4(keccak256(abi.encodePacked(\"setAddr(bytes32,address)\")));\n\n  ENSController public ensController;\n  ENSRegistry public ensRegistry;\n\n  uint256 private chainId;\n\n  // events\n\n  event BalanceTransferred(\n    address archanovaAccount,\n    address etherspotAccount,\n    uint256 value\n  );\n\n  event ERC20TokenTransferred(\n    address archanovaAccount,\n    address etherspotAccount,\n    address token,\n    uint256 tokenAmount\n  );\n\n  event ENSNodeTransferred(\n    address archanovaAccount,\n    address etherspotAccount,\n    bytes32 ensNode\n  );\n\n\n  /**\n   * @dev public constructor\n   */\n  constructor()\n    public\n    Initializable()\n  {\n    uint chainId_;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      chainId_ := chainid()\n    }\n\n    chainId = chainId_;\n  }\n\n  // external functions\n\n  /**\n   * @notice Initializes `ArchanovaMigrator` contract\n   * @param ensController_ ens controller address\n   * @param ensRegistry_ ens registry address\n   */\n  function initialize(\n    ENSController ensController_,\n    ENSRegistry ensRegistry_\n  )\n    external\n    onlyInitializer\n  {\n    ensController = ensController_;\n    ensRegistry = ensRegistry_;\n  }\n\n  function transferBalance(\n    address payable archanovaAccount,\n    address payable etherspotAccount,\n    uint256 value,\n    bytes calldata archanovaAccountDeviceSignature\n  )\n    external\n  {\n    _verifyArchanovaAccountOwner(\n      archanovaAccount,\n      etherspotAccount,\n      archanovaAccountDeviceSignature\n    );\n\n    _transferBalance(\n      archanovaAccount,\n      etherspotAccount,\n      value\n    );\n  }\n\n  function transferERC20Tokens(\n    address payable archanovaAccount,\n    address payable etherspotAccount,\n    address[] calldata tokens,\n    uint256[] calldata tokensAmounts,\n    bytes calldata archanovaAccountDeviceSignature\n  )\n    external\n  {\n    _verifyArchanovaAccountOwner(\n      archanovaAccount,\n      etherspotAccount,\n      archanovaAccountDeviceSignature\n    );\n\n    _transferERC20Tokens(\n      archanovaAccount,\n      etherspotAccount,\n      tokens,\n      tokensAmounts\n    );\n  }\n\n  function transferBalanceAndERC20Tokens(\n    address payable archanovaAccount,\n    address payable etherspotAccount,\n    uint256 value,\n    address[] calldata tokens,\n    uint256[] calldata tokensAmounts,\n    bytes calldata archanovaAccountDeviceSignature\n  )\n    external\n  {\n    _verifyArchanovaAccountOwner(\n      archanovaAccount,\n      etherspotAccount,\n      archanovaAccountDeviceSignature\n    );\n\n    _transferBalance(\n      archanovaAccount,\n      etherspotAccount,\n      value\n    );\n\n    _transferERC20Tokens(\n      archanovaAccount,\n      etherspotAccount,\n      tokens,\n      tokensAmounts\n    );\n  }\n\n  function transferENSNode(\n    address payable archanovaAccount,\n    address payable etherspotAccount,\n    bytes32 ensNode,\n    bytes calldata archanovaAccountDeviceSignature\n  )\n    external\n  {\n    _verifyArchanovaAccountOwner(\n      archanovaAccount,\n      etherspotAccount,\n      archanovaAccountDeviceSignature\n    );\n\n    _transferENSNode(\n      archanovaAccount,\n      etherspotAccount,\n      ensNode\n    );\n  }\n\n  function transferBalanceAndENSNode(\n    address payable archanovaAccount,\n    address payable etherspotAccount,\n    uint256 value,\n    bytes32 ensNode,\n    bytes calldata archanovaAccountDeviceSignature\n  )\n    external\n  {\n    _verifyArchanovaAccountOwner(\n      archanovaAccount,\n      etherspotAccount,\n      archanovaAccountDeviceSignature\n    );\n\n    _transferBalance(\n      archanovaAccount,\n      etherspotAccount,\n      value\n    );\n\n    _transferENSNode(\n      archanovaAccount,\n      etherspotAccount,\n      ensNode\n    );\n  }\n\n  function transferERC20TokensAndENSNode(\n    address payable archanovaAccount,\n    address payable etherspotAccount,\n    address[] calldata tokens,\n    uint256[] calldata tokensAmounts,\n    bytes32 ensNode,\n    bytes calldata archanovaAccountDeviceSignature\n  )\n    external\n  {\n    _verifyArchanovaAccountOwner(\n      archanovaAccount,\n      etherspotAccount,\n      archanovaAccountDeviceSignature\n    );\n\n    _transferERC20Tokens(\n      archanovaAccount,\n      etherspotAccount,\n      tokens,\n      tokensAmounts\n    );\n\n    _transferENSNode(\n      archanovaAccount,\n      etherspotAccount,\n      ensNode\n    );\n  }\n\n  function transferBalanceAndERC20TokensAndENSNode(\n    address payable archanovaAccount,\n    address payable etherspotAccount,\n    uint256 value,\n    address[] calldata tokens,\n    uint256[] calldata tokensAmounts,\n    bytes32 ensNode,\n    bytes calldata archanovaAccountDeviceSignature\n  )\n    external\n  {\n    _verifyArchanovaAccountOwner(\n      archanovaAccount,\n      etherspotAccount,\n      archanovaAccountDeviceSignature\n    );\n\n    _transferBalance(\n      archanovaAccount,\n      etherspotAccount,\n      value\n    );\n\n    _transferERC20Tokens(\n      archanovaAccount,\n      etherspotAccount,\n      tokens,\n      tokensAmounts\n    );\n\n    _transferENSNode(\n      archanovaAccount,\n      etherspotAccount,\n      ensNode\n    );\n  }\n\n  // private functions\n\n  function _transferBalance(\n    address payable archanovaAccount,\n    address payable etherspotAccount,\n    uint256 value\n  )\n    private\n  {\n    ArchanovaAccount(archanovaAccount).executeTransaction(\n      etherspotAccount,\n      value,\n      new bytes(0)\n    );\n\n    emit BalanceTransferred(\n      archanovaAccount,\n      etherspotAccount,\n      value\n    );\n  }\n\n  function _transferERC20Tokens(\n    address payable archanovaAccount,\n    address payable etherspotAccount,\n    address[] memory tokens,\n    uint256[] memory tokensAmounts\n  )\n    private\n  {\n    uint tokensLen = tokens.length;\n\n    for (uint i = 0; i < tokensLen; i++) {\n      bytes memory response = ArchanovaAccount(archanovaAccount).executeTransaction(\n        payable(tokens[i]),\n        0,\n        abi.encodeWithSelector(\n          ERC20Token(tokens[i]).transfer.selector,\n          etherspotAccount,\n          tokensAmounts[i]\n        )\n      );\n\n      if (response.length > 0) {\n        require(\n          abi.decode(response, (bool)),\n          \"ArchanovaMigrator: ERC20Token transfer reverted\"\n        );\n      }\n\n      emit ERC20TokenTransferred(\n        archanovaAccount,\n        etherspotAccount,\n        tokens[i],\n        tokensAmounts[i]\n      );\n    }\n  }\n\n  function _transferENSNode(\n    address payable archanovaAccount,\n    address payable etherspotAccount,\n    bytes32 ensNode\n  )\n    private\n  {\n    ArchanovaAccount(archanovaAccount).executeTransaction(\n      payable(address(ensRegistry)),\n      0,\n      abi.encodeWithSelector(\n        ensRegistry.setResolver.selector,\n        ensNode,\n        address(ensController)\n      )\n    );\n\n    ArchanovaAccount(archanovaAccount).executeTransaction(\n      payable(address(ensController)),\n      0,\n      abi.encodeWithSelector(\n        ensController.syncAddr.selector,\n        ensNode\n      )\n    );\n\n    ArchanovaAccount(archanovaAccount).executeTransaction(\n      payable(address(ensController)),\n      0,\n      abi.encodeWithSelector(\n        ENS_CONTROLLER_SET_ADDR_SELECTOR,\n        ensNode,\n        etherspotAccount\n      )\n    );\n\n    ArchanovaAccount(archanovaAccount).executeTransaction(\n      payable(address(ensRegistry)),\n      0,\n      abi.encodeWithSelector(\n        ensRegistry.setOwner.selector,\n        ensNode,\n        etherspotAccount\n      )\n    );\n\n    emit ENSNodeTransferred(\n      archanovaAccount,\n      etherspotAccount,\n      ensNode\n    );\n  }\n\n  // private functions (views)\n\n  function _verifyArchanovaAccountOwner(\n    address payable archanovaAccount,\n    address payable etherspotAccount,\n    bytes memory archanovaAccountDeviceSignature\n  )\n    private\n    view\n  {\n    address recovered = keccak256(abi.encodePacked(\n        \"\\x19Ethereum Signed Message:\\n32\",\n        keccak256(abi.encodePacked(\n          chainId,\n          address(this),\n          MIGRATION_MESSAGE_PREFIX,\n          archanovaAccount,\n          etherspotAccount\n        ))\n      )).recoverAddress(archanovaAccountDeviceSignature);\n\n    (bool exists, bool isOwner, ) = ArchanovaAccount(archanovaAccount).devices(\n      recovered\n    );\n\n    require(\n      exists && isOwner,\n      \"ArchanovaMigrator: invalid archanovaAccountDeviceSignature\"\n    );\n  }\n}\n"
    },
    "@etherspot/contracts/src/common/libs/ECDSALib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title ECDSA library\n *\n * @dev Based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.3.0/contracts/cryptography/ECDSA.sol#L26\n */\nlibrary ECDSALib {\n  function recoverAddress(\n    bytes32 messageHash,\n    bytes memory signature\n  )\n    internal\n    pure\n    returns (address)\n  {\n    address result = address(0);\n\n    if (signature.length == 65) {\n      bytes32 r;\n      bytes32 s;\n      uint8 v;\n\n      // solhint-disable-next-line no-inline-assembly\n      assembly {\n        r := mload(add(signature, 0x20))\n        s := mload(add(signature, 0x40))\n        v := byte(0, mload(add(signature, 0x60)))\n      }\n\n      if (v < 27) {\n        v += 27;\n      }\n\n      if (v == 27 || v == 28) {\n        result = ecrecover(messageHash, v, r, s);\n      }\n    }\n\n    return result;\n  }\n\n  function toEthereumSignedMessageHash(\n    bytes32 messageHash\n  )\n    internal\n    pure\n    returns (bytes32)\n  {\n    return keccak256(abi.encodePacked(\n      \"\\x19Ethereum Signed Message:\\n32\",\n      messageHash\n    ));\n  }\n}\n"
    },
    "@etherspot/contracts/src/common/lifecycle/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Initializable\n *\n * @dev Contract module which provides access control mechanism, where\n * there is the initializer account that can be granted exclusive access to\n * specific functions.\n *\n * The initializer account will be tx.origin during contract deployment and will be removed on first use.\n * Use `onlyInitializer` modifier on contract initialize process.\n *\n * @author Stanisław Głogowski <stan@pillarproject.io>\n */\ncontract Initializable {\n  address private initializer;\n\n  // events\n\n  /**\n   * @dev Emitted after `onlyInitializer`\n   * @param initializer initializer address\n   */\n  event Initialized(\n    address initializer\n  );\n\n  // modifiers\n\n  /**\n   * @dev Throws if tx.origin is not the initializer\n   */\n  modifier onlyInitializer() {\n    require(\n      // solhint-disable-next-line avoid-tx-origin\n      tx.origin == initializer,\n      \"Initializable: tx.origin is not the initializer\"\n    );\n\n    /// @dev removes initializer\n    initializer = address(0);\n\n    _;\n\n    emit Initialized(\n      // solhint-disable-next-line avoid-tx-origin\n      tx.origin\n    );\n  }\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor()\n    internal\n  {\n    // solhint-disable-next-line avoid-tx-origin\n    initializer = tx.origin;\n  }\n\n   // external functions (views)\n\n  /**\n   * @notice Check if contract is initialized\n   * @return true when contract is initialized\n   */\n  function isInitialized()\n    external\n    view\n    returns (bool)\n  {\n    return initializer == address(0);\n  }\n}\n"
    },
    "@etherspot/contracts/src/common/token/ERC20Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"../libs/SafeMathLib.sol\";\n\n\n/**\n * @title ERC20 token\n *\n * @dev Based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.3.0/contracts/token/ERC20/ERC20.sol\n */\ncontract ERC20Token {\n  using SafeMathLib for uint256;\n\n  string public name;\n  string public symbol;\n  uint8 public decimals;\n  uint256 public totalSupply;\n\n  mapping(address => uint256) internal balances;\n  mapping(address => mapping(address => uint256)) internal allowances;\n\n  // events\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n\n  /**\n   * @dev internal constructor\n   */\n  constructor() internal {}\n\n  // external functions\n\n  function transfer(\n    address to,\n    uint256 value\n  )\n    external\n    returns (bool)\n  {\n    _transfer(_getSender(), to, value);\n\n    return true;\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  )\n    virtual\n    external\n    returns (bool)\n  {\n    address sender = _getSender();\n\n    _transfer(from, to, value);\n    _approve(from, sender, allowances[from][sender].sub(value));\n\n    return true;\n  }\n\n  function approve(\n    address spender,\n    uint256 value\n  )\n    virtual\n    external\n    returns (bool)\n  {\n    _approve(_getSender(), spender, value);\n\n    return true;\n  }\n\n  // external functions (views)\n\n  function balanceOf(\n    address owner\n  )\n    virtual\n    external\n    view\n    returns (uint256)\n  {\n    return balances[owner];\n  }\n\n  function allowance(\n    address owner,\n    address spender\n  )\n    virtual\n    external\n    view\n    returns (uint256)\n  {\n    return allowances[owner][spender];\n  }\n\n  // internal functions\n\n  function _transfer(\n    address from,\n    address to,\n    uint256 value\n  )\n    virtual\n    internal\n  {\n    require(\n      from != address(0),\n      \"ERC20Token: cannot transfer from 0x0 address\"\n    );\n    require(\n      to != address(0),\n      \"ERC20Token: cannot transfer to 0x0 address\"\n    );\n\n    balances[from] = balances[from].sub(value);\n    balances[to] = balances[to].add(value);\n\n    emit Transfer(from, to, value);\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 value\n  )\n    virtual\n    internal\n  {\n    require(\n      owner != address(0),\n      \"ERC20Token: cannot approve from 0x0 address\"\n    );\n    require(\n      spender != address(0),\n      \"ERC20Token: cannot approve to 0x0 address\"\n    );\n\n    allowances[owner][spender] = value;\n\n    emit Approval(owner, spender, value);\n  }\n\n  function _mint(\n    address owner,\n    uint256 value\n  )\n    virtual\n    internal\n  {\n    require(\n      owner != address(0),\n      \"ERC20Token: cannot mint to 0x0 address\"\n    );\n    require(\n      value > 0,\n      \"ERC20Token: cannot mint 0 value\"\n    );\n\n    balances[owner] = balances[owner].add(value);\n    totalSupply = totalSupply.add(value);\n\n    emit Transfer(address(0), owner, value);\n  }\n\n  function _burn(\n    address owner,\n    uint256 value\n  )\n    virtual\n    internal\n  {\n    require(\n      owner != address(0),\n      \"ERC20Token: cannot burn from 0x0 address\"\n    );\n\n    balances[owner] = balances[owner].sub(\n      value,\n      \"ERC20Token: burn value exceeds balance\"\n    );\n\n    totalSupply = totalSupply.sub(value);\n\n    emit Transfer(owner, address(0), value);\n  }\n\n  // internal functions (views)\n\n  function _getSender()\n    virtual\n    internal\n    view\n    returns (address)\n  {\n    return msg.sender;\n  }\n}\n"
    },
    "@etherspot/contracts/src/ens/ENSController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../common/access/Guarded.sol\";\nimport \"../common/lifecycle/Initializable.sol\";\nimport \"../common/signature/SignatureValidator.sol\";\nimport \"../gateway/GatewayRecipient.sol\";\nimport \"./resolvers/ENSAddressResolver.sol\";\nimport \"./resolvers/ENSNameResolver.sol\";\nimport \"./resolvers/ENSPubKeyResolver.sol\";\nimport \"./resolvers/ENSTextResolver.sol\";\nimport \"./ENSRegistry.sol\";\n\n\n/**\n * @title ENS controller\n *\n * @notice ENS subnode registrar\n *\n * @dev The process of adding root node consists of 3 steps:\n * 1. `submitNode` - should be called from ENS node owner,\n * 2. Change ENS node owner in ENS registry to ENS controller,\n * 3. `verifyNode` - should be called from previous ENS node owner,\n *\n * To register sub node, `msg.sender` need to send valid signature from one of guardian key.\n * Once registration is complete `msg.sender` becoming both node owner and `addr` record value.\n *\n * After registration sub node cannot be replaced.\n *\n * @author Stanisław Głogowski <stan@pillarproject.io>\n */\ncontract ENSController is Guarded, Initializable, SignatureValidator, GatewayRecipient, ENSAddressResolver, ENSNameResolver, ENSPubKeyResolver, ENSTextResolver {\n  struct SubNodeRegistration {\n    address account;\n    bytes32 node;\n    bytes32 label;\n  }\n\n  bytes4 private constant INTERFACE_META_ID = bytes4(keccak256(abi.encodePacked(\"supportsInterface(bytes4)\")));\n\n  bytes32 private constant HASH_PREFIX_SUB_NODE_REGISTRATION = keccak256(\n    \"SubNodeRegistration(address account,bytes32 node,bytes32 label)\"\n  );\n\n  ENSRegistry public registry;\n\n  mapping(bytes32 => address) public nodeOwners;\n\n  // events\n\n  /**\n   * @dev Emitted when new node is submitted\n   * @param node node name hash\n   * @param owner owner address\n   */\n  event NodeSubmitted(\n    bytes32 node,\n    address owner\n  );\n\n  /**\n   * @dev Emitted when the existing owner is verified\n   * @param node node name hash\n   */\n  event NodeVerified(\n    bytes32 node\n  );\n\n  /**\n   * @dev Emitted when new node is released\n   * @param node node name hash\n   * @param owner owner address\n   */\n  event NodeReleased(\n    bytes32 node,\n    address owner\n  );\n\n  /**\n   * @dev Emitted when ENS registry address is changed\n   * @param registry registry address\n   */\n  event RegistryChanged(\n    address registry\n  );\n\n  /**\n   * @dev Public constructor\n   */\n  constructor() public Guarded() Initializable() SignatureValidator() {}\n\n  // external functions\n\n  /**\n   * @notice Initializes `ENSController` contract\n   * @param registry_ ENS registry address\n   * @param gateway_ gateway address\n   */\n  function initialize(\n    ENSRegistry registry_,\n    address[] calldata guardians_,\n    address gateway_\n  )\n    external\n    onlyInitializer\n  {\n    require(\n      address(registry_) != address(0),\n      \"ENSController: cannot set 0x0 registry\"\n    );\n\n    registry = registry_;\n\n    // Guarded\n    _initializeGuarded(guardians_);\n\n    // GatewayRecipient\n    _initializeGatewayRecipient(gateway_);\n  }\n\n  /**\n   * @notice Sets registry\n   * @param registry_ registry address\n   */\n  function setRegistry(\n    ENSRegistry registry_\n  )\n    external\n    onlyGuardian\n  {\n    require(\n      address(registry_) != address(0),\n      \"ENSController: cannot set 0x0 registry\"\n    );\n\n    require(\n      registry_ != registry,\n      \"ENSController: registry already set\"\n    );\n\n    registry = registry_;\n\n    emit RegistryChanged(\n      address(registry)\n    );\n  }\n\n  /**\n   * @notice Submits node\n   * @dev Should be called from the current ENS node owner\n   * @param node node name hash\n   */\n  function submitNode(\n    bytes32 node\n  )\n    external\n  {\n    address owner = _getContextAccount();\n\n    require(\n      _addr(node) == address(0),\n      \"ENSController: node already exists\"\n    );\n\n    require(\n      nodeOwners[node] == address(0),\n      \"ENSController: node already submitted\"\n    );\n\n    require(\n      registry.owner(node) == owner,\n      \"ENSController: invalid ens node owner\"\n    );\n\n    nodeOwners[node] = owner;\n\n    emit NodeSubmitted(node, owner);\n  }\n\n  /**\n   * @notice Verifies node\n   * @dev Should be called from the previous ENS node owner\n   * @param node node name hash\n   */\n  function verifyNode(\n    bytes32 node\n  )\n    external\n  {\n    address owner = _getContextAccount();\n\n    require(\n      _addr(node) == address(0),\n      \"ENSController: node already exists\"\n    );\n\n    require(\n      nodeOwners[node] == owner,\n      \"ENSController: invalid node owner\"\n    );\n\n    require(\n      registry.owner(node) == address(this),\n      \"ENSController: invalid ens node owner\"\n    );\n\n    _setAddr(node, address(this));\n\n    registry.setResolver(node, address(this));\n\n    emit NodeVerified(node);\n  }\n\n  /**\n   * @notice Releases node\n   * @dev Should be called from the previous ENS node owner\n   * @param node node name hash\n   */\n  function releaseNode(\n    bytes32 node\n  )\n    external\n  {\n    address owner = _getContextAccount();\n\n    require(\n      _addr(node) == address(this),\n      \"ENSController: node doesn't exist\"\n    );\n\n    require(\n      nodeOwners[node] == owner,\n      \"ENSController: invalid node owner\"\n    );\n\n    registry.setOwner(node, owner);\n\n    delete nodeOwners[node];\n\n    emit NodeReleased(node, owner);\n  }\n\n  /**\n   * @notice Sync address\n   * @param node node name hash\n   */\n  function syncAddr(\n    bytes32 node\n  )\n    external\n  {\n    address account = _getContextAccount();\n\n    require(\n      account == registry.owner(node),\n      \"ENSController: caller is not the node owner\"\n    );\n\n    require(\n      registry.resolver(node) == address(this),\n      \"ENSController: invalid node resolver\"\n    );\n\n    require(\n      _addr(node) == address(0),\n      \"ENSController: node already in sync\"\n    );\n\n    _setAddr(node, account);\n  }\n\n  /**\n   * @notice Registers sub node\n   * @param node node name hash\n   * @param label label hash\n   * @param guardianSignature guardian signature\n   */\n  function registerSubNode(\n    bytes32 node,\n    bytes32 label,\n    bytes calldata guardianSignature\n  )\n    external\n  {\n    address account = _getContextAccount();\n\n    bytes32 messageHash = _hashSubNodeRegistration(\n      account,\n      node,\n      label\n    );\n\n    require(\n      _verifyGuardianSignature(messageHash, guardianSignature),\n      \"ENSController: invalid guardian signature\"\n    );\n\n    bytes32 subNode = keccak256(\n      abi.encodePacked(\n        node,\n        label\n      )\n    );\n\n    require(\n      _addr(node) == address(this),\n      \"ENSController: invalid node\"\n    );\n\n    require(\n      _addr(subNode) == address(0),\n      \"ENSController: label already taken\"\n    );\n\n    registry.setSubnodeRecord(node, label, address(this), address(this), 0);\n    registry.setOwner(subNode, account);\n\n    _setAddr(subNode, account);\n  }\n\n  // external functions (pure)\n  function supportsInterface(\n    bytes4 interfaceID\n  )\n    external\n    pure\n    returns(bool)\n  {\n    return interfaceID == INTERFACE_META_ID ||\n    interfaceID == INTERFACE_ADDR_ID ||\n    interfaceID == INTERFACE_ADDRESS_ID ||\n    interfaceID == INTERFACE_NAME_ID ||\n    interfaceID == INTERFACE_PUB_KEY_ID ||\n    interfaceID == INTERFACE_TEXT_ID;\n  }\n\n  // public functions (views)\n\n  /**\n   * @notice Hashes `SubNodeRegistration` message payload\n   * @param subNodeRegistration struct\n   * @return hash\n   */\n  function hashSubNodeRegistration(\n    SubNodeRegistration memory subNodeRegistration\n  )\n    public\n    view\n    returns (bytes32)\n  {\n    return _hashSubNodeRegistration(\n      subNodeRegistration.account,\n      subNodeRegistration.node,\n      subNodeRegistration.label\n    );\n  }\n\n  // internal functions (views)\n\n  function _isNodeOwner(\n    bytes32 node\n  )\n    internal\n    override\n    view\n    returns (bool)\n  {\n    return registry.owner(node) == _getContextAccount();\n  }\n\n  // private functions (views)\n\n  function _hashSubNodeRegistration(\n    address account,\n    bytes32 node,\n    bytes32 label\n  )\n    private\n    view\n    returns (bytes32)\n  {\n    return _hashMessagePayload(HASH_PREFIX_SUB_NODE_REGISTRATION, abi.encodePacked(\n      account,\n      node,\n      label\n    ));\n  }\n}\n"
    },
    "@etherspot/contracts/src/ens/ENSRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title ENS registry\n *\n * @dev Base on https://github.com/ensdomains/ens/blob/ff0f41747c05f1598973b0fe7ad0d9e09565dfcd/contracts/ENSRegistry.sol\n */\ncontract ENSRegistry {\n  struct Record {\n    address owner;\n    address resolver;\n    uint64 ttl;\n  }\n\n  mapping (bytes32 => Record) private records;\n  mapping (address => mapping(address => bool)) private operators;\n\n  // events\n\n  event NewOwner(\n    bytes32 indexed node,\n    bytes32 indexed label,\n    address owner\n  );\n\n  event Transfer(\n    bytes32 indexed node,\n    address owner\n  );\n\n  event NewResolver(\n    bytes32 indexed node,\n    address resolver\n  );\n\n  event NewTTL(\n    bytes32 indexed node,\n    uint64 ttl\n  );\n\n  event ApprovalForAll(\n    address indexed owner,\n    address indexed operator,\n    bool approved\n  );\n\n  // modifiers\n\n  modifier authorised(\n    bytes32 node\n  )\n  {\n    address owner = records[node].owner;\n\n    require(\n      owner == msg.sender || operators[owner][msg.sender],\n      \"ENSRegistry: reverted by authorised modifier\"\n    );\n\n    _;\n  }\n\n  /**\n   * @dev Public constructor\n   */\n  constructor()\n    public\n  {\n    // solhint-disable-next-line avoid-tx-origin\n    records[0x0].owner = tx.origin;\n  }\n\n  // external functions\n\n  function setRecord(\n    bytes32 node,\n    address owner_,\n    address resolver_,\n    uint64 ttl_\n  )\n    external\n  {\n    setOwner(node, owner_);\n\n    _setResolverAndTTL(node, resolver_, ttl_);\n  }\n\n  function setTTL(\n    bytes32 node,\n    uint64 ttl_\n  )\n    external\n    authorised(node)\n  {\n    records[node].ttl = ttl_;\n\n    emit NewTTL(node, ttl_);\n  }\n\n  function setSubnodeRecord(\n    bytes32 node,\n    bytes32 label,\n    address owner_,\n    address resolver_,\n    uint64 ttl_\n  )\n    external\n  {\n    bytes32 subNode = setSubnodeOwner(node, label, owner_);\n\n    _setResolverAndTTL(subNode, resolver_, ttl_);\n  }\n\n  function setApprovalForAll(\n    address operator,\n    bool approved\n  )\n    external\n  {\n    operators[msg.sender][operator] = approved;\n\n    emit ApprovalForAll(\n      msg.sender,\n      operator,\n      approved\n    );\n  }\n\n  // external functions (views)\n\n  function owner(\n    bytes32 node\n  )\n    external\n    view\n    returns (address)\n  {\n    address addr = records[node].owner;\n\n    if (addr == address(this)) {\n      return address(0x0);\n    }\n\n    return addr;\n  }\n\n  function resolver(\n    bytes32 node\n  )\n    external\n    view\n    returns (address)\n  {\n    return records[node].resolver;\n  }\n\n  function ttl(\n    bytes32 node\n  )\n    external\n    view\n    returns (uint64)\n  {\n    return records[node].ttl;\n  }\n\n  function recordExists(\n    bytes32 node\n  )\n    external\n    view\n    returns (bool)\n  {\n    return records[node].owner != address(0x0);\n  }\n\n  function isApprovedForAll(\n    address owner_,\n    address operator\n  )\n    external\n    view\n    returns (bool)\n  {\n    return operators[owner_][operator];\n  }\n\n  // public functions\n\n  function setOwner(\n    bytes32 node,\n    address owner_\n  )\n    public\n    authorised(node)\n  {\n    records[node].owner = owner_;\n\n    emit Transfer(node, owner_);\n  }\n\n  function setResolver(\n    bytes32 node,\n    address resolver_\n  )\n    public\n    authorised(node)\n  {\n    records[node].resolver = resolver_;\n\n    emit NewResolver(node, resolver_);\n  }\n\n  function setSubnodeOwner(\n    bytes32 node,\n    bytes32 label,\n    address owner_\n  )\n    public\n    authorised(node)\n    returns(bytes32)\n  {\n    bytes32 subNode = keccak256(abi.encodePacked(node, label));\n\n    records[subNode].owner = owner_;\n\n    emit NewOwner(node, label, owner_);\n\n    return subNode;\n  }\n\n  // private functions\n\n  function _setResolverAndTTL(\n    bytes32 node,\n    address resolver_,\n    uint64 ttl_\n  )\n    private\n  {\n    if (resolver_ != records[node].resolver) {\n      records[node].resolver = resolver_;\n\n      emit NewResolver(node, resolver_);\n    }\n\n    if (ttl_ != records[node].ttl) {\n      records[node].ttl = ttl_;\n\n      emit NewTTL(node, ttl_);\n    }\n  }\n}\n"
    },
    "@etherspot/contracts/src/common/libs/SafeMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Safe math library\n *\n * @dev Based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.3.0/contracts/math/SafeMath.sol\n */\nlibrary SafeMathLib {\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n\n    require(c >= a, \"SafeMathLib: addition overflow\");\n\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, \"SafeMathLib: subtraction overflow\");\n  }\n\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n\n    return a - b;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n\n    require(c / a == b, \"SafeMathLib: multiplication overflow\");\n\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, \"SafeMathLib: division by zero\");\n  }\n\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n\n    return a / b;\n  }\n\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, \"SafeMathLib: modulo by zero\");\n  }\n\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n\n    return a % b;\n  }\n}\n"
    },
    "@etherspot/contracts/src/common/access/Guarded.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"../libs/ECDSALib.sol\";\n\n\n/**\n * @title Guarded\n *\n * @dev Contract module which provides a guardian-type control mechanism.\n * It allows key accounts to have guardians and restricts specific methods to be accessible by guardians only.\n *\n * Each guardian account can remove other guardians\n *\n * Use `_initializeGuarded` to initialize the contract\n *\n * @author Stanisław Głogowski <stan@pillarproject.io>\n */\ncontract Guarded {\n  using ECDSALib for bytes32;\n\n  mapping(address => bool) private guardians;\n\n  // events\n\n  /**\n   * @dev Emitted when a new guardian is added\n   * @param sender sender address\n   * @param guardian guardian address\n   */\n  event GuardianAdded(\n    address sender,\n    address guardian\n  );\n\n  /**\n   * @dev Emitted when the existing guardian is removed\n   * @param sender sender address\n   * @param guardian guardian address\n   */\n  event GuardianRemoved(\n    address sender,\n    address guardian\n  );\n\n  // modifiers\n\n  /**\n   * @dev Throws if tx.origin is not a guardian account\n   */\n  modifier onlyGuardian() {\n    require(\n      // solhint-disable-next-line avoid-tx-origin\n      guardians[tx.origin],\n      \"Guarded: tx.origin is not the guardian\"\n    );\n\n    _;\n  }\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor() internal {}\n\n  // external functions\n\n  /**\n   * @notice Adds a new guardian\n   * @param guardian guardian address\n   */\n  function addGuardian(\n    address guardian\n  )\n    external\n    onlyGuardian\n  {\n    _addGuardian(guardian);\n  }\n\n  /**\n   * @notice Removes the existing guardian\n   * @param guardian guardian address\n   */\n  function removeGuardian(\n    address guardian\n  )\n    external\n    onlyGuardian\n  {\n    require(\n      // solhint-disable-next-line avoid-tx-origin\n      tx.origin != guardian,\n      \"Guarded: cannot remove self\"\n    );\n\n    require(\n      guardians[guardian],\n      \"Guarded: guardian doesn't exist\"\n    );\n\n    guardians[guardian] = false;\n\n    emit GuardianRemoved(\n      // solhint-disable-next-line avoid-tx-origin\n      tx.origin,\n      guardian\n    );\n  }\n\n  // external functions (views)\n\n  /**\n   * @notice Check if guardian exists\n   * @param guardian guardian address\n   * @return true when guardian exists\n   */\n  function isGuardian(\n    address guardian\n  )\n    external\n    view\n    returns (bool)\n  {\n    return guardians[guardian];\n  }\n\n  /**\n   * @notice Verifies guardian signature\n   * @param messageHash message hash\n   * @param signature signature\n   * @return true on correct guardian signature\n   */\n  function verifyGuardianSignature(\n    bytes32 messageHash,\n    bytes calldata signature\n  )\n    external\n    view\n    returns (bool)\n  {\n    return _verifyGuardianSignature(\n      messageHash,\n      signature\n    );\n  }\n\n  // internal functions\n\n  /**\n   * @notice Initializes `Guarded` contract\n   * @dev If `guardians_` array is empty `tx.origin` is added as guardian account\n   * @param guardians_ array of guardians addresses\n   */\n  function _initializeGuarded(\n    address[] memory guardians_\n  )\n    internal\n  {\n    if (guardians_.length == 0) {\n      // solhint-disable-next-line avoid-tx-origin\n      _addGuardian(tx.origin);\n    } else {\n      uint guardiansLen = guardians_.length;\n      for (uint i = 0; i < guardiansLen; i++) {\n        _addGuardian(guardians_[i]);\n      }\n    }\n  }\n\n\n  // internal functions (views)\n\n  function _verifyGuardianSignature(\n    bytes32 messageHash,\n    bytes memory signature\n  )\n    internal\n    view\n    returns (bool)\n  {\n    address guardian = messageHash.recoverAddress(signature);\n\n    return guardians[guardian];\n  }\n\n  // private functions\n\n  function _addGuardian(\n    address guardian\n  )\n    private\n  {\n    require(\n      guardian != address(0),\n      \"Guarded: cannot add 0x0 guardian\"\n    );\n\n    require(\n      !guardians[guardian],\n      \"Guarded: guardian already exists\"\n    );\n\n    guardians[guardian] = true;\n\n    emit GuardianAdded(\n      // solhint-disable-next-line avoid-tx-origin\n      tx.origin,\n      guardian\n    );\n  }\n}\n"
    },
    "@etherspot/contracts/src/common/signature/SignatureValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"../libs/ECDSALib.sol\";\n\n/**\n * @title Signature validator\n *\n * @author Stanisław Głogowski <stan@pillarproject.io>\n */\ncontract SignatureValidator {\n  using ECDSALib for bytes32;\n\n  uint256 public chainId;\n\n  /**\n   * @dev internal constructor\n   */\n  constructor() internal {\n    uint256 chainId_;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      chainId_ := chainid()\n    }\n\n    chainId = chainId_;\n  }\n\n  // internal functions\n\n  function _hashMessagePayload(\n    bytes32 messagePrefix,\n    bytes memory messagePayload\n  )\n    internal\n    view\n    returns (bytes32)\n  {\n    return keccak256(abi.encodePacked(\n      chainId,\n      address(this),\n      messagePrefix,\n      messagePayload\n    )).toEthereumSignedMessageHash();\n  }\n}\n"
    },
    "@etherspot/contracts/src/gateway/GatewayRecipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"../common/libs/BytesLib.sol\";\n\n\n/**\n * @title Gateway recipient\n *\n * @notice Gateway target contract\n *\n * @author Stanisław Głogowski <stan@pillarproject.io>\n */\ncontract GatewayRecipient {\n  using BytesLib for bytes;\n\n  address public gateway;\n\n  /**\n   * @dev internal constructor\n   */\n  constructor() internal {}\n\n  // internal functions\n\n  /**\n   * @notice Initializes `GatewayRecipient` contract\n   * @param gateway_ `Gateway` contract address\n   */\n  function _initializeGatewayRecipient(\n    address gateway_\n  )\n    internal\n  {\n    gateway = gateway_;\n  }\n\n  // internal functions (views)\n\n  /**\n   * @notice Gets gateway context account\n   * @return context account address\n   */\n  function _getContextAccount()\n    internal\n    view\n    returns (address)\n  {\n    return _getContextAddress(40);\n  }\n\n  /**\n   * @notice Gets gateway context sender\n   * @return context sender address\n   */\n  function _getContextSender()\n    internal\n    view\n    returns (address)\n  {\n    return _getContextAddress(20);\n  }\n\n  /**\n   * @notice Gets gateway context data\n   * @return context data\n   */\n  function _getContextData()\n    internal\n    view\n    returns (bytes calldata)\n  {\n    bytes calldata result;\n\n    if (_isGatewaySender()) {\n      result = msg.data[:msg.data.length - 40];\n    } else {\n      result = msg.data;\n    }\n\n    return result;\n  }\n\n  // private functions (views)\n\n  function _getContextAddress(\n    uint256 offset\n  )\n    private\n    view\n    returns (address)\n  {\n    address result = address(0);\n\n    if (_isGatewaySender()) {\n      uint from = msg.data.length - offset;\n      result = bytes(msg.data[from:from + 20]).toAddress();\n    } else {\n      result = msg.sender;\n    }\n\n    return result;\n  }\n\n  function _isGatewaySender()\n    private\n    view\n    returns (bool)\n  {\n    bool result;\n\n    if (msg.sender == gateway) {\n      require(\n        msg.data.length >= 44,\n        \"GatewayRecipient: invalid msg.data\"\n      );\n\n      result = true;\n    }\n\n    return result;\n  }\n}\n"
    },
    "@etherspot/contracts/src/ens/resolvers/ENSAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./ENSAbstractResolver.sol\";\n\n\n/**\n * @title ENS abstract address resolver\n *\n * @dev Base on https://github.com/ensdomains/resolvers/blob/f7d62ab04bfe1692a4344f6f1d31ff81315a98c3/contracts/profiles/AddrResolver.sol\n */\nabstract contract ENSAddressResolver is ENSAbstractResolver {\n  bytes4 internal constant INTERFACE_ADDR_ID = bytes4(keccak256(abi.encodePacked(\"addr(bytes32)\")));\n  bytes4 internal constant INTERFACE_ADDRESS_ID = bytes4(keccak256(abi.encodePacked(\"addr(bytes32,uint)\")));\n\n  uint internal constant COIN_TYPE_ETH = 60;\n\n  mapping(bytes32 => mapping(uint => bytes)) internal resolverAddresses;\n\n  // events\n\n  event AddrChanged(\n    bytes32 indexed node,\n    address addr\n  );\n\n  event AddressChanged(\n    bytes32 indexed node,\n    uint coinType,\n    bytes newAddress\n  );\n\n  // external functions\n\n  function setAddr(\n    bytes32 node,\n    address addr_\n  )\n    external\n    onlyNodeOwner(node)\n  {\n    _setAddr(node, addr_);\n  }\n\n  function setAddr(\n    bytes32 node,\n    uint coinType,\n    bytes memory addr_\n  )\n    external\n    onlyNodeOwner(node)\n  {\n    _setAddr(node, coinType, addr_);\n  }\n\n  // external functions (views)\n\n  function addr(\n    bytes32 node\n  )\n    external\n    view\n    returns (address)\n  {\n    return _addr(node);\n  }\n\n  function addr(\n    bytes32 node,\n    uint coinType\n  )\n    external\n    view\n    returns (bytes memory)\n  {\n    return resolverAddresses[node][coinType];\n  }\n\n  // internal functions\n\n  function _setAddr(\n    bytes32 node,\n    address addr_\n  )\n    internal\n  {\n    _setAddr(node, COIN_TYPE_ETH, _addressToBytes(addr_));\n  }\n\n  function _setAddr(\n    bytes32 node,\n    uint coinType,\n    bytes memory addr_\n  )\n    internal\n  {\n    emit AddressChanged(node, coinType, addr_);\n\n    if(coinType == COIN_TYPE_ETH) {\n      emit AddrChanged(node, _bytesToAddress(addr_));\n    }\n\n    resolverAddresses[node][coinType] = addr_;\n  }\n\n  // internal functions (views)\n\n  function _addr(\n    bytes32 node\n  )\n    internal\n    view\n    returns (address)\n  {\n    address result;\n\n    bytes memory addr_ = resolverAddresses[node][COIN_TYPE_ETH];\n\n    if (addr_.length > 0) {\n      result = _bytesToAddress(addr_);\n    }\n\n    return result;\n  }\n\n  // private function (pure)\n\n  function _bytesToAddress(\n    bytes memory data\n  )\n    private\n    pure\n    returns(address payable)\n  {\n    address payable result;\n\n    require(data.length == 20);\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      result := div(mload(add(data, 32)), exp(256, 12))\n    }\n\n    return result;\n  }\n\n  function _addressToBytes(\n    address addr_\n  )\n    private\n    pure\n    returns(bytes memory)\n  {\n    bytes memory result = new bytes(20);\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      mstore(add(result, 32), mul(addr_, exp(256, 12)))\n    }\n\n    return result;\n  }\n}\n"
    },
    "@etherspot/contracts/src/ens/resolvers/ENSNameResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./ENSAbstractResolver.sol\";\n\n\n/**\n * @title ENS abstract name resolver\n *\n * @dev Base on https://github.com/ensdomains/resolvers/blob/f7d62ab04bfe1692a4344f6f1d31ff81315a98c3/contracts/profiles/NameResolver.sol\n */\nabstract contract ENSNameResolver is ENSAbstractResolver {\n  bytes4 internal constant INTERFACE_NAME_ID = bytes4(keccak256(abi.encodePacked(\"name(bytes32)\")));\n\n  mapping(bytes32 => string) internal resolverNames;\n\n  // events\n\n  event NameChanged(\n    bytes32 indexed node,\n    string name\n  );\n\n  // external functions\n\n  function setName(\n    bytes32 node,\n    string calldata name\n  )\n    external\n    onlyNodeOwner(node)\n  {\n    resolverNames[node] = name;\n\n    emit NameChanged(node, name);\n  }\n\n  // external functions (views)\n\n  function name(\n    bytes32 node\n  )\n    external\n    view\n    returns (string memory)\n  {\n    return resolverNames[node];\n  }\n}\n"
    },
    "@etherspot/contracts/src/ens/resolvers/ENSPubKeyResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./ENSAbstractResolver.sol\";\n\n\n/**\n * @title ENS abstract pub key resolver\n *\n * @dev Base on https://github.com/ensdomains/resolvers/blob/f7d62ab04bfe1692a4344f6f1d31ff81315a98c3/contracts/profiles/PubkeyResolver.sol\n */\nabstract contract ENSPubKeyResolver is ENSAbstractResolver {\n  bytes4 internal constant INTERFACE_PUB_KEY_ID = bytes4(keccak256(abi.encodePacked(\"pubkey(bytes32)\")));\n\n  struct PubKey {\n    bytes32 x;\n    bytes32 y;\n  }\n\n  mapping(bytes32 => PubKey) internal resolverPubKeys;\n\n  // events\n\n  event PubkeyChanged(\n    bytes32 indexed node,\n    bytes32 x,\n    bytes32 y\n  );\n\n  // external functions (views)\n\n  function setPubkey(\n    bytes32 node,\n    bytes32 x,\n    bytes32 y\n  )\n    external\n    onlyNodeOwner(node)\n  {\n    resolverPubKeys[node] = PubKey(x, y);\n\n    emit PubkeyChanged(node, x, y);\n  }\n\n  // external functions (views)\n\n  function pubkey(\n    bytes32 node\n  )\n    external\n    view\n    returns (bytes32 x, bytes32 y)\n  {\n    return (resolverPubKeys[node].x, resolverPubKeys[node].y);\n  }\n}\n"
    },
    "@etherspot/contracts/src/ens/resolvers/ENSTextResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./ENSAbstractResolver.sol\";\n\n\n/**\n * @title ENS abstract text resolver\n *\n * @dev Base on https://github.com/ensdomains/resolvers/blob/f7d62ab04bfe1692a4344f6f1d31ff81315a98c3/contracts/profiles/TextResolver.sol\n */\nabstract contract ENSTextResolver is ENSAbstractResolver {\n  bytes4 internal constant INTERFACE_TEXT_ID = bytes4(keccak256(abi.encodePacked(\"text(bytes32,string)\")));\n\n  mapping(bytes32 => mapping(string => string)) internal resolverTexts;\n\n  // events\n\n  event TextChanged(\n    bytes32 indexed node,\n    string indexed indexedKey,\n    string key\n  );\n\n  // external functions (views)\n\n  function setText(\n    bytes32 node,\n    string calldata key,\n    string calldata value\n  )\n    external\n    onlyNodeOwner(node)\n  {\n    resolverTexts[node][key] = value;\n\n    emit TextChanged(node, key, key);\n  }\n\n  // external functions (views)\n\n  function text(\n    bytes32 node,\n    string calldata key\n  )\n    external\n    view\n    returns (string memory)\n  {\n    return resolverTexts[node][key];\n  }\n}\n"
    },
    "@etherspot/contracts/src/common/libs/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Bytes library\n *\n * @author Stanisław Głogowski <stan@pillarproject.io>\n */\nlibrary BytesLib {\n  /**\n   * @notice Converts bytes to address\n   * @param data data\n   * @return address\n   */\n  function toAddress(\n    bytes memory data\n  )\n    internal\n    pure\n    returns (address)\n  {\n    address result;\n\n    require(\n      data.length == 20,\n      \"BytesLib: invalid data length\"\n    );\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      result := div(mload(add(data, 0x20)), 0x1000000000000000000000000)\n    }\n\n    return result;\n  }\n}\n"
    },
    "@etherspot/contracts/src/ens/resolvers/ENSAbstractResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title ENS abstract resolver\n *\n * @dev Base on https://github.com/ensdomains/resolvers/blob/f7d62ab04bfe1692a4344f6f1d31ff81315a98c3/contracts/ResolverBase.sol\n */\nabstract contract ENSAbstractResolver {\n  // modifiers\n\n  modifier onlyNodeOwner(bytes32 node)\n  {\n    require(\n      _isNodeOwner(node),\n      \"ENSAbstractResolver: reverted by onlyNodeOwner modifier\"\n    );\n\n    _;\n  }\n\n  // internal functions (views)\n\n  function _isNodeOwner(\n    bytes32 node\n  )\n    internal\n    virtual\n    view\n    returns (bool);\n}\n"
    }
  },
  "settings": {
    "evmVersion": "istanbul",
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}