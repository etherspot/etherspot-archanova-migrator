{
  "address": "0x3E53A712c7a0C375136c23501A7fBC17A48De6b0",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address[]",
          "name": "friends",
          "type": "address[]"
        }
      ],
      "name": "FriendsChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "requiredFriends",
          "type": "uint256"
        }
      ],
      "name": "RequiredFriendsChanged",
      "type": "event"
    },
    {
      "constant": true,
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "accounts",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "requiredFriends",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_device",
          "type": "address"
        },
        {
          "internalType": "address[]",
          "name": "_friends",
          "type": "address[]"
        },
        {
          "internalType": "bytes",
          "name": "_signatures",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "_gasFee",
          "type": "uint256"
        }
      ],
      "name": "recoverAccount",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "internalType": "address[]",
          "name": "_friends",
          "type": "address[]"
        }
      ],
      "name": "setFriends",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_requiredFriends",
          "type": "uint256"
        }
      ],
      "name": "setRequiredFriends",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_requiredFriends",
          "type": "uint256"
        },
        {
          "internalType": "address[]",
          "name": "_friends",
          "type": "address[]"
        }
      ],
      "name": "setup",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x2c71396e0c11eb5d8dc798af42d3d7652c73fcca38d6cbd61e1ad3c7b168c696",
  "receipt": {
    "to": null,
    "from": "0x61f6dFAca3de098fB895A83197C59bC50a8AB39e",
    "contractAddress": "0x3E53A712c7a0C375136c23501A7fBC17A48De6b0",
    "transactionIndex": 0,
    "gasUsed": "1247123",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x08b3fe81906b34ec7ff5d9ce8e4e3b94f3245287b0734d2026e90fe21d5d5e8c",
    "transactionHash": "0x2c71396e0c11eb5d8dc798af42d3d7652c73fcca38d6cbd61e1ad3c7b168c696",
    "logs": [],
    "blockNumber": 32,
    "cumulativeGasUsed": "1247123",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "2d65759aa936f218b80b5cf1af768225",
  "metadata": "{\"compiler\":{\"version\":\"0.5.17+commit.d19bba13.mod\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"friends\",\"type\":\"address[]\"}],\"name\":\"FriendsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requiredFriends\",\"type\":\"uint256\"}],\"name\":\"RequiredFriendsChanged\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requiredFriends\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_device\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_friends\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"_signatures\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_gasFee\",\"type\":\"uint256\"}],\"name\":\"recoverAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_friends\",\"type\":\"address[]\"}],\"name\":\"setFriends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requiredFriends\",\"type\":\"uint256\"}],\"name\":\"setRequiredFriends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requiredFriends\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_friends\",\"type\":\"address[]\"}],\"name\":\"setup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{},\"title\":\"Account Friend Recovery\"},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"src/account/AccountFriendRecovery.sol\":\"AccountFriendRecovery\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"openzeppelin-solidity/contracts/cryptography/ECDSA.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @title Elliptic curve signature operations\\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\\n * See https://github.com/ethereum/solidity/issues/864\\n */\\n\\nlibrary ECDSA {\\n    /**\\n     * @dev Recover signer address from a message by using their signature\\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\\n     * @param signature bytes signature, the signature is generated using web3.eth.sign()\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // Check the signature length\\n        if (signature.length != 65) {\\n            return (address(0));\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\\n        if (v < 27) {\\n            v += 27;\\n        }\\n\\n        // If the version is correct return the signer address\\n        if (v != 27 && v != 28) {\\n            return (address(0));\\n        } else {\\n            return ecrecover(hash, v, r, s);\\n        }\\n    }\\n\\n    /**\\n     * toEthSignedMessageHash\\n     * @dev prefix a bytes32 value with \\\"\\\\x19Ethereum Signed Message:\\\"\\n     * and hash the result\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n}\\n\",\"keccak256\":\"0xb48974d92a87053dc1d6c5389f3d1b2ad522dec23afcb508eaa935d98dfdc0b6\"},\"openzeppelin-solidity/contracts/math/SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @title SafeMath\\n * @dev Unsigned math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n    /**\\n    * @dev Multiplies two unsigned integers, reverts on overflow.\\n    */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\n    */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Adds two unsigned integers, reverts on overflow.\\n    */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\n    * reverts when dividing by zero.\\n    */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0x965012d27b4262d7a41f5028cbb30c51ebd9ecd4be8fb30380aaa7a3c64fbc8b\"},\"solidity-bytes-utils/contracts/BytesLib.sol\":{\"content\":\"/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\n\\npragma solidity ^0.5.0;\\n\\n\\nlibrary BytesLib {\\n    function concat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add \\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(0x40, and(\\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n              not(31) // Round down to the nearest 32 bytes.\\n            ))\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes_slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes_slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes_slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(\\n                            fslot,\\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\\n                        ),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes_slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n                \\n                for { \\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint _start,\\n        uint _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_bytes.length >= (_start + _length));\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\\n        require(_bytes.length >= (_start + 20));\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\\n        require(_bytes.length >= (_start + 1));\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\\n        require(_bytes.length >= (_start + 2));\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\\n        require(_bytes.length >= (_start + 4));\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\\n        require(_bytes.length >= (_start + 8));\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\\n        require(_bytes.length >= (_start + 12));\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\\n        require(_bytes.length >= (_start + 16));\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\\n        require(_bytes.length >= (_start + 32));\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\\n        require(_bytes.length >= (_start + 32));\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                // the next line is the loop condition:\\n                // while(uint(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(\\n        bytes storage _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes_slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes_slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint(mc < end) + cb == 2)\\n                        for {} eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\",\"keccak256\":\"0xde793835499803e9a2b59683de8bca5b77e2c4dc63748cf8b72973193e65e656\"},\"src/account/AbstractAccount.sol\":{\"content\":\"pragma solidity ^0.5.10;\\n\\nimport \\\"./ERC1271.sol\\\";\\n\\n\\n/**\\n * @title Abstract Account\\n */\\ncontract AbstractAccount is ERC1271 {\\n\\n  event DeviceAdded(address device, bool isOwner);\\n  event DeviceRemoved(address device);\\n  event TransactionExecuted(address recipient, uint256 value, bytes data, bytes response);\\n\\n  struct Device {\\n    bool isOwner;\\n    bool exists;\\n    bool existed;\\n  }\\n\\n  mapping(address => Device) public devices;\\n\\n  function addDevice(address _device, bool _isOwner) public;\\n\\n  function removeDevice(address _device) public;\\n\\n  function executeTransaction(address payable _recipient, uint256 _value, bytes memory _data) public returns (bytes memory _response);\\n}\\n\",\"keccak256\":\"0xb35b2e0062a9305b14439db512f6d9d243e5d54c432d5136d080413bd0a19b45\"},\"src/account/AccountFriendRecovery.sol\":{\"content\":\"pragma solidity ^0.5.10;\\n\\nimport \\\"openzeppelin-solidity/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/math/SafeMath.sol\\\";\\nimport \\\"solidity-bytes-utils/contracts/BytesLib.sol\\\";\\nimport \\\"./AbstractAccount.sol\\\";\\nimport \\\"./AccountLibrary.sol\\\";\\n\\n\\n/**\\n * @title Account Friend Recovery\\n */\\ncontract AccountFriendRecovery {\\n\\n  event RequiredFriendsChanged(address account, uint256 requiredFriends);\\n  event FriendsChanged(address account, address[] friends);\\n\\n  using AccountLibrary for AbstractAccount;\\n  using ECDSA for bytes32;\\n  using SafeMath for uint256;\\n  using BytesLib for bytes;\\n\\n  struct Account {\\n    uint256 nonce;\\n    uint256 requiredFriends;\\n    address[] friends;\\n    mapping(address => bool) friendsMap;\\n  }\\n\\n  mapping(address => Account) public accounts;\\n\\n  modifier onlyConnectedAccount() {\\n    require(\\n      AbstractAccount(msg.sender).isOwnerDevice(address(this))\\n    );\\n\\n    _;\\n  }\\n\\n  function setup(uint256 _requiredFriends, address[] memory _friends) onlyConnectedAccount public {\\n    _setRequiredFriends(_requiredFriends);\\n    _setFriends(_friends);\\n  }\\n\\n  function setRequiredFriends(uint256 _requiredFriends) onlyConnectedAccount public {\\n    _setRequiredFriends(_requiredFriends);\\n  }\\n\\n  function setFriends(address[] memory _friends) onlyConnectedAccount public {\\n    _setFriends(_friends);\\n  }\\n\\n  function recoverAccount(\\n    address _account,\\n    address _device,\\n    address[] memory _friends,\\n    bytes memory _signatures,\\n    uint256 _gasFee\\n  ) public {\\n    uint friendsLength = _friends.length;\\n    uint signaturesLength = _signatures.length;\\n\\n    require(\\n      accounts[_account].requiredFriends > 0 &&\\n      accounts[_account].requiredFriends == friendsLength &&\\n      signaturesLength == friendsLength * 65\\n    );\\n\\n    bytes32 _messageHash = keccak256(\\n      abi.encodePacked(\\n        address(this),\\n        msg.sig,\\n        _account,\\n        _device,\\n        accounts[_account].nonce,\\n        _gasFee,\\n        tx.gasprice\\n      )\\n    ).toEthSignedMessageHash();\\n\\n    for (uint i = 0; i < friendsLength; i++) {\\n      bytes memory signature = _signatures.slice(i * 65, 65);\\n\\n      require(\\n        accounts[_account].friendsMap[_friends[i]] &&\\n        AbstractAccount(_friends[i]).verifyOwnerSignature(_messageHash, signature)\\n      );\\n\\n      for (uint j = 0; j < friendsLength; j++) {\\n        if (j != i) {\\n          require(_friends[i] != _friends[j]);\\n        }\\n      }\\n    }\\n\\n    accounts[_account].nonce = accounts[_account].nonce.add(1);\\n\\n    AbstractAccount(_account).addDevice(_device, true);\\n\\n    if (_gasFee > 0) {\\n      AbstractAccount(_account).executeTransaction(\\n        msg.sender,\\n        _gasFee.mul(tx.gasprice),\\n        new bytes(0)\\n      );\\n    }\\n  }\\n\\n  function _setRequiredFriends(uint256 _requiredFriends) private {\\n    accounts[msg.sender].requiredFriends = _requiredFriends;\\n\\n    emit RequiredFriendsChanged(msg.sender, _requiredFriends);\\n  }\\n\\n  function _setFriends(address[] memory _friends) private {\\n    uint friendsLength = accounts[msg.sender].friends.length;\\n    uint i;\\n\\n    for (i = 0; i < friendsLength; i++) {\\n      delete accounts[msg.sender].friendsMap[accounts[msg.sender].friends[i]];\\n    }\\n\\n    accounts[msg.sender].friends = _friends;\\n\\n    friendsLength = _friends.length;\\n\\n    for (i = 0; i < friendsLength; i++) {\\n      require(\\n        !accounts[msg.sender].friendsMap[_friends[i]] && _friends[i] != address(0)\\n      );\\n\\n      accounts[msg.sender].friendsMap[_friends[i]] = true;\\n    }\\n\\n    emit FriendsChanged(msg.sender, _friends);\\n  }\\n}\\n\",\"keccak256\":\"0xc474c5cb1f3e8f5dbdc5a7a0523bb1a4361cda38ed625270d512628c4855bf06\"},\"src/account/AccountLibrary.sol\":{\"content\":\"pragma solidity ^0.5.10;\\n\\nimport \\\"openzeppelin-solidity/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"./AbstractAccount.sol\\\";\\n\\n\\n/**\\n * @title Account Library\\n */\\nlibrary AccountLibrary {\\n\\n  using ECDSA for bytes32;\\n\\n  function isOwnerDevice(\\n    AbstractAccount _account,\\n    address _device\\n  ) internal view returns (bool) {\\n    bool isOwner;\\n    (isOwner,,) = _account.devices(_device);\\n    return isOwner;\\n  }\\n\\n  function isAnyDevice(\\n    AbstractAccount _account,\\n    address _device\\n  ) internal view returns (bool) {\\n    bool exists;\\n    (,exists,) = _account.devices(_device);\\n    return exists;\\n  }\\n\\n  function isExistedDevice(\\n    AbstractAccount _account,\\n    address _device\\n  ) internal view returns (bool) {\\n    bool existed;\\n    (,,existed) = _account.devices(_device);\\n    return existed;\\n  }\\n\\n  function verifyOwnerSignature(\\n    AbstractAccount _account,\\n    bytes32 _messageHash,\\n    bytes memory _signature\\n  ) internal view returns (bool _result) {\\n    address _recovered = _messageHash.recover(_signature);\\n\\n    if (_recovered != address(0)) {\\n      _result = isOwnerDevice(_account, _recovered);\\n    }\\n  }\\n\\n  function verifySignature(\\n    AbstractAccount _account,\\n    bytes32 _messageHash,\\n    bytes memory _signature,\\n    bool _strict\\n  ) internal view returns (bool _result) {\\n    address _recovered = _messageHash.recover(_signature);\\n\\n    if (_recovered != address(0)) {\\n      if (_strict) {\\n        _result = isAnyDevice(_account, _recovered);\\n      } else {\\n        _result = isExistedDevice(_account, _recovered);\\n      }\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x27bb32ce38d819d6e2c86a1f593e2e98855541eafac58c54ede6e6e4756826fa\"},\"src/account/ERC1271.sol\":{\"content\":\"pragma solidity ^0.5.10;\\n\\ncontract ERC1271 {\\n\\n  // bytes4(keccak256(\\\"isValidSignature(bytes,bytes)\\\")\\n  bytes4 constant internal MAGICVALUE = 0x20c13b0b;\\n\\n  /**\\n   * @dev Should return whether the signature provided is valid for the provided data\\n   * @param _data Arbitrary length data signed on the behalf of address(this)\\n   * @param _signature Signature byte array associated with _data\\n   *\\n   * MUST return the bytes4 magic value 0x20c13b0b when function passes.\\n   * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\\n   * MUST allow external calls\\n   */\\n  function isValidSignature(\\n    bytes memory _data,\\n    bytes memory _signature\\n  ) public view returns (bytes4 magicValue);\\n}\\n\",\"keccak256\":\"0xa128c7faad858e42f18b7bd1e2d9bb0bd77ba1970d86133a05d4a0821394a906\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061159e806100206000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c80630e2983031461005c5780634d56bbc91461011e57806353f3aac61461014c5780635e5c06e2146102e5578063b8755fe214610344575b600080fd5b61011c6004803603604081101561007257600080fd5b81019080803590602001909291908035906020019064010000000081111561009957600080fd5b8201836020820111156100ab57600080fd5b803590602001918460208302840111640100000000831117156100cd57600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600081840152601f19601f8201169050808301925050505050505091929192905050506103fc565b005b61014a6004803603602081101561013457600080fd5b8101908080359060200190929190505050610444565b005b6102e3600480360360a081101561016257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001906401000000008111156101bf57600080fd5b8201836020820111156101d157600080fd5b803590602001918460208302840111640100000000831117156101f357600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600081840152601f19601f8201169050808301925050505050505091929192908035906020019064010000000081111561025357600080fd5b82018360208201111561026557600080fd5b8035906020019184600183028401116401000000008311171561028757600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050919291929080359060200190929190505050610482565b005b610327600480360360208110156102fb57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610bfa565b604051808381526020018281526020019250505060405180910390f35b6103fa6004803603602081101561035a57600080fd5b810190808035906020019064010000000081111561037757600080fd5b82018360208201111561038957600080fd5b803590602001918460208302840111640100000000831117156103ab57600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600081840152601f19601f820116905080830192505050505050509192919290505050610c1e565b005b610425303373ffffffffffffffffffffffffffffffffffffffff16610c5c90919063ffffffff16565b61042e57600080fd5b61043782610d3c565b61044081610df0565b5050565b61046d303373ffffffffffffffffffffffffffffffffffffffff16610c5c90919063ffffffff16565b61047657600080fd5b61047f81610d3c565b50565b60008351905060008351905060008060008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206001015411801561051f5750816000808973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060010154145b801561052d57506041820281145b61053657600080fd5b60006106c7306000357fffffffff00000000000000000000000000000000000000000000000000000000168a8a6000808e73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000154893a604051602001808873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1660601b8152601401877bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191681526004018673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1660601b81526014018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1660601b81526014018481526020018381526020018281526020019750505050505050506040516020818303038152906040528051906020012061121c565b905060008090505b838110156108735760606106f2604183026041896112749092919063ffffffff16565b90506000808b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600301600089848151811061074357fe5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff1680156107d957506107d883828a85815181106107ab57fe5b602002602001015173ffffffffffffffffffffffffffffffffffffffff166113009092919063ffffffff16565b5b6107e257600080fd5b60008090505b85811015610864578281146108575788818151811061080357fe5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1689848151811061082d57fe5b602002602001015173ffffffffffffffffffffffffffffffffffffffff16141561085657600080fd5b5b80806001019150506107e8565b505080806001019150506106cf565b506108c960016000808b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000015461136190919063ffffffff16565b6000808a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001819055508773ffffffffffffffffffffffffffffffffffffffff1663811d54dc8860016040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018215151515815260200192505050600060405180830381600087803b15801561099a57600080fd5b505af11580156109ae573d6000803e3d6000fd5b505050506000841115610bf0578773ffffffffffffffffffffffffffffffffffffffff16633f579f42336109eb3a8861138090919063ffffffff16565b60006040519080825280601f01601f191660200182016040528015610a1f5781602001600182028038833980820191505090505b506040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200183815260200180602001828103825283818151815260200191508051906020019080838360005b83811015610aa7578082015181840152602081019050610a8c565b50505050905090810190601f168015610ad45780820380516001836020036101000a031916815260200191505b50945050505050600060405180830381600087803b158015610af557600080fd5b505af1158015610b09573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052506020811015610b3357600080fd5b8101908080516040519392919084640100000000821115610b5357600080fd5b83820191506020820185811115610b6957600080fd5b8251866001820283011164010000000082111715610b8657600080fd5b8083526020830192505050908051906020019080838360005b83811015610bba578082015181840152602081019050610b9f565b50505050905090810190601f168015610be75780820380516001836020036101000a031916815260200191505b50604052505050505b5050505050505050565b60006020528060005260406000206000915090508060000154908060010154905082565b610c47303373ffffffffffffffffffffffffffffffffffffffff16610c5c90919063ffffffff16565b610c5057600080fd5b610c5981610df0565b50565b6000808373ffffffffffffffffffffffffffffffffffffffff1663e7b4cac6846040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060606040518083038186803b158015610cdc57600080fd5b505afa158015610cf0573d6000803e3d6000fd5b505050506040513d6060811015610d0657600080fd5b81019080805190602001909291908051906020019092919080519060200190929190505050905050809150508091505092915050565b806000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600101819055507f66f92348ae6d17cffb78f8bb20d50b5ac8c983e02794942c183116d3add7d2c03382604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019250505060405180910390a150565b60008060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060020180549050905060008090505b81811015610f58576000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060030160008060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206002018381548110610ed657fe5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff02191690558080600101915050610e3f565b826000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206002019080519060200190610fad92919061149c565b5082519150600090505b8181101561116b576000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600301600084838151811061100e57fe5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff161580156110ab5750600073ffffffffffffffffffffffffffffffffffffffff1683828151811061108a57fe5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1614155b6110b457600080fd5b60016000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600301600085848151811061110557fe5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055508080600101915050610fb7565b7fca4c23b9ce256db47e380479ed723fa548baf50a55c53aec593bbc3c8be1bcf13384604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200180602001828103825283818151815260200191508051906020019060200280838360005b838110156112035780820151818401526020810190506111e8565b50505050905001935050505060405180910390a1505050565b60008160405160200180807f19457468657265756d205369676e6564204d6573736167653a0a333200000000815250601c01828152602001915050604051602081830303815290604052805190602001209050919050565b60608183018451101561128657600080fd5b60608215600081146112a3576040519150602082016040526112f4565b6040519150601f8416801560200281840101858101878315602002848b0101015b818310156112e157805183526020830192506020810190506112c4565b50868552601f19601f8301166040525050505b50809150509392505050565b60008061131683856113ba90919063ffffffff16565b9050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614611359576113568582610c5c565b91505b509392505050565b60008082840190508381101561137657600080fd5b8091505092915050565b60008083141561139357600090506113b4565b60008284029050828482816113a457fe5b04146113af57600080fd5b809150505b92915050565b60008060008060418551146113d55760009350505050611496565b6020850151925060408501519150606085015160001a9050601b8160ff16101561140057601b810190505b601b8160ff16141580156114185750601c8160ff1614155b156114295760009350505050611496565b60018682858560405160008152602001604052604051808581526020018460ff1660ff1681526020018381526020018281526020019450505050506020604051602081039080840390855afa158015611486573d6000803e3d6000fd5b5050506020604051035193505050505b92915050565b828054828255906000526020600020908101928215611515579160200282015b828111156115145782518260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550916020019190600101906114bc565b5b5090506115229190611526565b5090565b61156691905b8082111561156257600081816101000a81549073ffffffffffffffffffffffffffffffffffffffff02191690555060010161152c565b5090565b9056fea265627a7a723158204e7fc5e61555a49d56f7b5c4207ccaa6ba0795b2c64d15ade5a14a9a9035932264736f6c63430005110032",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100575760003560e01c80630e2983031461005c5780634d56bbc91461011e57806353f3aac61461014c5780635e5c06e2146102e5578063b8755fe214610344575b600080fd5b61011c6004803603604081101561007257600080fd5b81019080803590602001909291908035906020019064010000000081111561009957600080fd5b8201836020820111156100ab57600080fd5b803590602001918460208302840111640100000000831117156100cd57600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600081840152601f19601f8201169050808301925050505050505091929192905050506103fc565b005b61014a6004803603602081101561013457600080fd5b8101908080359060200190929190505050610444565b005b6102e3600480360360a081101561016257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001906401000000008111156101bf57600080fd5b8201836020820111156101d157600080fd5b803590602001918460208302840111640100000000831117156101f357600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600081840152601f19601f8201169050808301925050505050505091929192908035906020019064010000000081111561025357600080fd5b82018360208201111561026557600080fd5b8035906020019184600183028401116401000000008311171561028757600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050919291929080359060200190929190505050610482565b005b610327600480360360208110156102fb57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610bfa565b604051808381526020018281526020019250505060405180910390f35b6103fa6004803603602081101561035a57600080fd5b810190808035906020019064010000000081111561037757600080fd5b82018360208201111561038957600080fd5b803590602001918460208302840111640100000000831117156103ab57600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600081840152601f19601f820116905080830192505050505050509192919290505050610c1e565b005b610425303373ffffffffffffffffffffffffffffffffffffffff16610c5c90919063ffffffff16565b61042e57600080fd5b61043782610d3c565b61044081610df0565b5050565b61046d303373ffffffffffffffffffffffffffffffffffffffff16610c5c90919063ffffffff16565b61047657600080fd5b61047f81610d3c565b50565b60008351905060008351905060008060008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206001015411801561051f5750816000808973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060010154145b801561052d57506041820281145b61053657600080fd5b60006106c7306000357fffffffff00000000000000000000000000000000000000000000000000000000168a8a6000808e73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000154893a604051602001808873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1660601b8152601401877bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191681526004018673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1660601b81526014018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1660601b81526014018481526020018381526020018281526020019750505050505050506040516020818303038152906040528051906020012061121c565b905060008090505b838110156108735760606106f2604183026041896112749092919063ffffffff16565b90506000808b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600301600089848151811061074357fe5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff1680156107d957506107d883828a85815181106107ab57fe5b602002602001015173ffffffffffffffffffffffffffffffffffffffff166113009092919063ffffffff16565b5b6107e257600080fd5b60008090505b85811015610864578281146108575788818151811061080357fe5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1689848151811061082d57fe5b602002602001015173ffffffffffffffffffffffffffffffffffffffff16141561085657600080fd5b5b80806001019150506107e8565b505080806001019150506106cf565b506108c960016000808b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000015461136190919063ffffffff16565b6000808a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001819055508773ffffffffffffffffffffffffffffffffffffffff1663811d54dc8860016040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018215151515815260200192505050600060405180830381600087803b15801561099a57600080fd5b505af11580156109ae573d6000803e3d6000fd5b505050506000841115610bf0578773ffffffffffffffffffffffffffffffffffffffff16633f579f42336109eb3a8861138090919063ffffffff16565b60006040519080825280601f01601f191660200182016040528015610a1f5781602001600182028038833980820191505090505b506040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200183815260200180602001828103825283818151815260200191508051906020019080838360005b83811015610aa7578082015181840152602081019050610a8c565b50505050905090810190601f168015610ad45780820380516001836020036101000a031916815260200191505b50945050505050600060405180830381600087803b158015610af557600080fd5b505af1158015610b09573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052506020811015610b3357600080fd5b8101908080516040519392919084640100000000821115610b5357600080fd5b83820191506020820185811115610b6957600080fd5b8251866001820283011164010000000082111715610b8657600080fd5b8083526020830192505050908051906020019080838360005b83811015610bba578082015181840152602081019050610b9f565b50505050905090810190601f168015610be75780820380516001836020036101000a031916815260200191505b50604052505050505b5050505050505050565b60006020528060005260406000206000915090508060000154908060010154905082565b610c47303373ffffffffffffffffffffffffffffffffffffffff16610c5c90919063ffffffff16565b610c5057600080fd5b610c5981610df0565b50565b6000808373ffffffffffffffffffffffffffffffffffffffff1663e7b4cac6846040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060606040518083038186803b158015610cdc57600080fd5b505afa158015610cf0573d6000803e3d6000fd5b505050506040513d6060811015610d0657600080fd5b81019080805190602001909291908051906020019092919080519060200190929190505050905050809150508091505092915050565b806000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600101819055507f66f92348ae6d17cffb78f8bb20d50b5ac8c983e02794942c183116d3add7d2c03382604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019250505060405180910390a150565b60008060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060020180549050905060008090505b81811015610f58576000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060030160008060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206002018381548110610ed657fe5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff02191690558080600101915050610e3f565b826000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206002019080519060200190610fad92919061149c565b5082519150600090505b8181101561116b576000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600301600084838151811061100e57fe5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff161580156110ab5750600073ffffffffffffffffffffffffffffffffffffffff1683828151811061108a57fe5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1614155b6110b457600080fd5b60016000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600301600085848151811061110557fe5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055508080600101915050610fb7565b7fca4c23b9ce256db47e380479ed723fa548baf50a55c53aec593bbc3c8be1bcf13384604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200180602001828103825283818151815260200191508051906020019060200280838360005b838110156112035780820151818401526020810190506111e8565b50505050905001935050505060405180910390a1505050565b60008160405160200180807f19457468657265756d205369676e6564204d6573736167653a0a333200000000815250601c01828152602001915050604051602081830303815290604052805190602001209050919050565b60608183018451101561128657600080fd5b60608215600081146112a3576040519150602082016040526112f4565b6040519150601f8416801560200281840101858101878315602002848b0101015b818310156112e157805183526020830192506020810190506112c4565b50868552601f19601f8301166040525050505b50809150509392505050565b60008061131683856113ba90919063ffffffff16565b9050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614611359576113568582610c5c565b91505b509392505050565b60008082840190508381101561137657600080fd5b8091505092915050565b60008083141561139357600090506113b4565b60008284029050828482816113a457fe5b04146113af57600080fd5b809150505b92915050565b60008060008060418551146113d55760009350505050611496565b6020850151925060408501519150606085015160001a9050601b8160ff16101561140057601b810190505b601b8160ff16141580156114185750601c8160ff1614155b156114295760009350505050611496565b60018682858560405160008152602001604052604051808581526020018460ff1660ff1681526020018381526020018281526020019450505050506020604051602081039080840390855afa158015611486573d6000803e3d6000fd5b5050506020604051035193505050505b92915050565b828054828255906000526020600020908101928215611515579160200282015b828111156115145782518260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550916020019190600101906114bc565b5b5090506115229190611526565b5090565b61156691905b8082111561156257600081816101000a81549073ffffffffffffffffffffffffffffffffffffffff02191690555060010161152c565b5090565b9056fea265627a7a723158204e7fc5e61555a49d56f7b5c4207ccaa6ba0795b2c64d15ade5a14a9a9035932264736f6c63430005110032",
  "devdoc": {
    "methods": {},
    "title": "Account Friend Recovery"
  },
  "userdoc": {
    "methods": {}
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 1698,
        "contract": "src/account/AccountFriendRecovery.sol:AccountFriendRecovery",
        "label": "accounts",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_struct(Account)1694_storage)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_struct(Account)1694_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct AccountFriendRecovery.Account)",
        "numberOfBytes": "32",
        "value": "t_struct(Account)1694_storage"
      },
      "t_struct(Account)1694_storage": {
        "encoding": "inplace",
        "label": "struct AccountFriendRecovery.Account",
        "members": [
          {
            "astId": 1684,
            "contract": "src/account/AccountFriendRecovery.sol:AccountFriendRecovery",
            "label": "nonce",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 1686,
            "contract": "src/account/AccountFriendRecovery.sol:AccountFriendRecovery",
            "label": "requiredFriends",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 1689,
            "contract": "src/account/AccountFriendRecovery.sol:AccountFriendRecovery",
            "label": "friends",
            "offset": 0,
            "slot": "2",
            "type": "t_array(t_address)dyn_storage"
          },
          {
            "astId": 1693,
            "contract": "src/account/AccountFriendRecovery.sol:AccountFriendRecovery",
            "label": "friendsMap",
            "offset": 0,
            "slot": "3",
            "type": "t_mapping(t_address,t_bool)"
          }
        ],
        "numberOfBytes": "128"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}