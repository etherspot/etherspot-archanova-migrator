{
  "language": "Solidity",
  "sources": {
    "src/account/AbstractAccount.sol": {
      "content": "pragma solidity ^0.5.10;\n\nimport \"./ERC1271.sol\";\n\n\n/**\n * @title Abstract Account\n */\ncontract AbstractAccount is ERC1271 {\n\n  event DeviceAdded(address device, bool isOwner);\n  event DeviceRemoved(address device);\n  event TransactionExecuted(address recipient, uint256 value, bytes data, bytes response);\n\n  struct Device {\n    bool isOwner;\n    bool exists;\n    bool existed;\n  }\n\n  mapping(address => Device) public devices;\n\n  function addDevice(address _device, bool _isOwner) public;\n\n  function removeDevice(address _device) public;\n\n  function executeTransaction(address payable _recipient, uint256 _value, bytes memory _data) public returns (bytes memory _response);\n}\n"
    },
    "src/account/ERC1271.sol": {
      "content": "pragma solidity ^0.5.10;\n\ncontract ERC1271 {\n\n  // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\n  bytes4 constant internal MAGICVALUE = 0x20c13b0b;\n\n  /**\n   * @dev Should return whether the signature provided is valid for the provided data\n   * @param _data Arbitrary length data signed on the behalf of address(this)\n   * @param _signature Signature byte array associated with _data\n   *\n   * MUST return the bytes4 magic value 0x20c13b0b when function passes.\n   * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n   * MUST allow external calls\n   */\n  function isValidSignature(\n    bytes memory _data,\n    bytes memory _signature\n  ) public view returns (bytes4 magicValue);\n}\n"
    },
    "src/address/AddressLibrary.sol": {
      "content": "pragma solidity ^0.5.10;\n\nimport \"openzeppelin-solidity/contracts/utils/Address.sol\";\nimport \"openzeppelin-solidity/contracts/cryptography/ECDSA.sol\";\nimport \"../account/AbstractAccount.sol\";\nimport \"../account/AccountLibrary.sol\";\n\n\n/**\n * @title Address Library\n */\nlibrary AddressLibrary {\n\n  using AccountLibrary for AbstractAccount;\n  using Address for address;\n  using ECDSA for bytes32;\n\n  function verifySignature(\n    address _address,\n    bytes32 _messageHash,\n    bytes memory _signature,\n    bool _strict\n  ) internal view returns (bool _result) {\n    if (_address.isContract()) {\n      _result = AbstractAccount(_address).verifySignature(\n        _messageHash,\n        _signature,\n        _strict\n      );\n    } else {\n      address _recovered = _messageHash.recover(_signature);\n      _result = _recovered == _address;\n    }\n  }\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/Address.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary Address {\n    /**\n     * Returns whether the target address is a contract\n     * @dev This function will return false if invoked during the constructor of a contract,\n     * as the code is not actually created until after the constructor finishes.\n     * @param account address of the account to check\n     * @return whether the target address is a contract\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/cryptography/ECDSA.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title Elliptic curve signature operations\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\n * See https://github.com/ethereum/solidity/issues/864\n */\n\nlibrary ECDSA {\n    /**\n     * @dev Recover signer address from a message by using their signature\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n     * @param signature bytes signature, the signature is generated using web3.eth.sign()\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // Check the signature length\n        if (signature.length != 65) {\n            return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n\n        // If the version is correct return the signer address\n        if (v != 27 && v != 28) {\n            return (address(0));\n        } else {\n            return ecrecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * toEthSignedMessageHash\n     * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\n     * and hash the result\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"
    },
    "src/account/AccountLibrary.sol": {
      "content": "pragma solidity ^0.5.10;\n\nimport \"openzeppelin-solidity/contracts/cryptography/ECDSA.sol\";\nimport \"./AbstractAccount.sol\";\n\n\n/**\n * @title Account Library\n */\nlibrary AccountLibrary {\n\n  using ECDSA for bytes32;\n\n  function isOwnerDevice(\n    AbstractAccount _account,\n    address _device\n  ) internal view returns (bool) {\n    bool isOwner;\n    (isOwner,,) = _account.devices(_device);\n    return isOwner;\n  }\n\n  function isAnyDevice(\n    AbstractAccount _account,\n    address _device\n  ) internal view returns (bool) {\n    bool exists;\n    (,exists,) = _account.devices(_device);\n    return exists;\n  }\n\n  function isExistedDevice(\n    AbstractAccount _account,\n    address _device\n  ) internal view returns (bool) {\n    bool existed;\n    (,,existed) = _account.devices(_device);\n    return existed;\n  }\n\n  function verifyOwnerSignature(\n    AbstractAccount _account,\n    bytes32 _messageHash,\n    bytes memory _signature\n  ) internal view returns (bool _result) {\n    address _recovered = _messageHash.recover(_signature);\n\n    if (_recovered != address(0)) {\n      _result = isOwnerDevice(_account, _recovered);\n    }\n  }\n\n  function verifySignature(\n    AbstractAccount _account,\n    bytes32 _messageHash,\n    bytes memory _signature,\n    bool _strict\n  ) internal view returns (bool _result) {\n    address _recovered = _messageHash.recover(_signature);\n\n    if (_recovered != address(0)) {\n      if (_strict) {\n        _result = isAnyDevice(_account, _recovered);\n      } else {\n        _result = isExistedDevice(_account, _recovered);\n      }\n    }\n  }\n}\n"
    },
    "src/virtualPayment/VirtualPaymentManager.sol": {
      "content": "pragma solidity ^0.5.10;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/cryptography/ECDSA.sol\";\nimport \"../address/AddressLibrary.sol\";\n\n/**\n * @title Virtual Payment Manager\n */\ncontract VirtualPaymentManager {\n\n  using AddressLibrary for address;\n  using ECDSA for bytes32;\n  using SafeMath for uint256;\n\n  event NewDeposit(address owner, address token, uint256 value);\n  event NewWithdrawal(address recipient, address token, uint256 value);\n  event NewWithdrawalRequest(address owner, address token, uint256 unlockedAt);\n  event NewPayment(address sender, address recipient, address token, uint256 id, uint256 value);\n\n  struct Deposit {\n    uint256 value;\n    uint256 withdrawalUnlockedAt;\n  }\n\n  struct Payment {\n    uint256 value;\n  }\n\n  mapping(address => mapping(address => Deposit)) public deposits;\n  mapping(bytes32 => Payment) public payments;\n\n  address public guardian;\n  uint256 public depositWithdrawalLockPeriod;\n\n  string constant ERR_INVALID_SIGNATURE = \"Invalid signature\";\n  string constant ERR_INVALID_OWNER = \"Invalid owner\";\n  string constant ERR_INVALID_VALUE = \"Invalid value\";\n  string constant ERR_INVALID_TOKEN = \"Invalid token\";\n\n  bytes4 constant ERC20_TRANSFER = bytes4(keccak256(\"transfer(address,uint256)\"));\n  bytes4 constant ERC20_TRANSFER_FROM = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n\n  constructor(\n    address _guardian,\n    uint256 _depositWithdrawalLockPeriod\n  ) public {\n    guardian = _guardian;\n    depositWithdrawalLockPeriod = _depositWithdrawalLockPeriod;\n  }\n\n  function getDepositValue(address _owner, address _token) public view returns (uint256) {\n    return deposits[_owner][_token].value;\n  }\n\n  function getDepositWithdrawalUnlockedAt(address _owner, address _token) public view returns (uint256) {\n    return deposits[_owner][_token].withdrawalUnlockedAt;\n  }\n\n  function() external payable {\n    require(\n      msg.value > 0,\n      ERR_INVALID_VALUE\n    );\n\n    deposits[msg.sender][address(0)].value = deposits[msg.sender][address(0)].value.add(msg.value);\n\n    emit NewDeposit(msg.sender, address(0), msg.value);\n  }\n\n  function depositTo(address _owner) payable public {\n    require(\n      _owner != address(0),\n      ERR_INVALID_OWNER\n    );\n    require(\n      msg.value > 0,\n      ERR_INVALID_VALUE\n    );\n\n    deposits[_owner][address(0)].value = deposits[_owner][address(0)].value.add(msg.value);\n\n    emit NewDeposit(msg.sender, address(0), msg.value);\n  }\n\n  function depositToken(address _token, uint256 _value) public {\n    require(\n      _token != address(0),\n      ERR_INVALID_TOKEN\n    );\n    require(\n      _value > 0,\n      ERR_INVALID_VALUE\n    );\n\n    _transferTokenFrom(_token, msg.sender, _value);\n\n    deposits[msg.sender][_token].value = deposits[msg.sender][_token].value.add(_value);\n\n    emit NewDeposit(msg.sender, _token, _value);\n  }\n\n  function depositTokenTo(address _owner, address _token, uint256 _value) public {\n    require(\n      _owner != address(0),\n      ERR_INVALID_OWNER\n    );\n    require(\n      _token != address(0),\n      ERR_INVALID_TOKEN\n    );\n    require(\n      _value > 0,\n      ERR_INVALID_VALUE\n    );\n\n    _transferTokenFrom(_token, msg.sender, _value);\n\n    deposits[_owner][_token].value = deposits[_owner][_token].value.add(_value);\n\n    emit NewDeposit(_owner, _token, _value);\n  }\n\n  function depositPayment(\n    address _sender,\n    address _recipient,\n    address _token,\n    uint256 _id,\n    uint256 _value,\n    bytes memory _senderSignature,\n    bytes memory _guardianSignature\n  ) public {\n    uint256 _processedValue = _processPayment(\n      _sender,\n      _recipient,\n      _token,\n      _id,\n      _value,\n      _senderSignature,\n      _guardianSignature\n    );\n\n    deposits[_recipient][_token].value = deposits[_recipient][_token].value.add(_processedValue);\n\n    emit NewPayment(_sender, _recipient, _token, _id, _processedValue);\n    emit NewDeposit(_recipient, _token, _processedValue);\n  }\n\n  function withdrawPayment(\n    address _sender,\n    address _recipient,\n    address _token,\n    uint256 _id,\n    uint256 _value,\n    bytes memory _senderSignature,\n    bytes memory _guardianSignature\n  ) public {\n    uint256 _processedValue = _processPayment(\n      _sender,\n      _recipient,\n      _token,\n      _id,\n      _value,\n      _senderSignature,\n      _guardianSignature\n    );\n\n    _transfer(_recipient, _token, _processedValue);\n\n    emit NewPayment(_sender, _recipient, _token, _id, _processedValue);\n    emit NewWithdrawal(_recipient, _token, _processedValue);\n  }\n\n  function withdrawDeposit(address _token) public {\n    if (\n      deposits[msg.sender][_token].withdrawalUnlockedAt != 0 && deposits[msg.sender][_token].withdrawalUnlockedAt <= now\n    ) {\n      _transfer(msg.sender, _token, deposits[msg.sender][_token].value);\n\n      emit NewWithdrawal(msg.sender, _token, deposits[msg.sender][_token].value);\n\n      delete deposits[msg.sender][_token];\n    } else {\n      deposits[msg.sender][_token].withdrawalUnlockedAt = now.add(depositWithdrawalLockPeriod);\n\n      emit NewWithdrawalRequest(msg.sender, _token, deposits[msg.sender][_token].withdrawalUnlockedAt);\n    }\n  }\n\n  function _processPayment(\n    address _sender,\n    address _recipient,\n    address _token,\n    uint256 _id,\n    uint256 _value,\n    bytes memory _senderSignature,\n    bytes memory _guardianSignature\n  ) private returns (uint256 _processedValue) {\n    bytes32 _messageHash = keccak256(\n      abi.encodePacked(\n        address(this),\n        _sender,\n        _recipient,\n        _token,\n        _id,\n        _value\n      )\n    ).toEthSignedMessageHash();\n\n    require(\n      _sender.verifySignature(_messageHash, _senderSignature, false),\n      ERR_INVALID_SIGNATURE\n    );\n    require(\n      guardian.verifySignature(_messageHash, _guardianSignature, true),\n      ERR_INVALID_SIGNATURE\n    );\n\n    bytes32 _paymentHash = keccak256(abi.encodePacked(\n        _sender,\n        _recipient,\n        _token,\n        _id\n      ));\n\n    require(\n      _value > 0,\n      ERR_INVALID_VALUE\n    );\n\n    if (payments[_paymentHash].value > 0) {\n      require(\n        payments[_paymentHash].value < _value,\n        ERR_INVALID_VALUE\n      );\n      _processedValue = _value.sub(payments[_paymentHash].value);\n    } else {\n      _processedValue = _value;\n    }\n\n    require(\n      deposits[_sender][_token].value >= _processedValue,\n      ERR_INVALID_VALUE\n    );\n\n    if (deposits[_sender][_token].withdrawalUnlockedAt > 0) {\n      delete deposits[_sender][_token].withdrawalUnlockedAt;\n    }\n\n    payments[_paymentHash].value = _value;\n    deposits[_sender][_token].value = deposits[_sender][_token].value.sub(_processedValue);\n  }\n\n  function _transfer(address _recipient, address _token, uint256 _value) private {\n    if (_token == address(0)) {\n      address payable _payableRecipient = address(uint160(_recipient));\n      _payableRecipient.transfer(_value);\n    } else {\n      _transferToken(_token, _recipient, _value);\n    }\n  }\n\n  function _transferToken(address _token, address _recipient, uint256 _value) private {\n    bool _success;\n\n    (_success,) = _token.call(abi.encodeWithSelector(\n      ERC20_TRANSFER,\n      _recipient,\n      _value\n    ));\n\n    require(_success);\n  }\n\n  function _transferTokenFrom(address _token, address _sender, uint256 _value) private {\n    bool _success;\n\n    (_success,) = _token.call(abi.encodeWithSelector(\n      ERC20_TRANSFER_FROM,\n      _sender,\n      address(this),\n      _value\n    ));\n\n    require(_success);\n  }\n}\n"
    },
    "openzeppelin-solidity/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n    * @dev Multiplies two unsigned integers, reverts on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two unsigned integers, reverts on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n"
    },
    "src/address/AddressLibraryWrapper.sol": {
      "content": "pragma solidity ^0.5.10;\n\nimport \"openzeppelin-solidity/contracts/cryptography/ECDSA.sol\";\nimport \"./AddressLibrary.sol\";\n\n\n/**\n * @title Address Library Wrapper\n */\ncontract AddressLibraryWrapper {\n\n  using AddressLibrary for address;\n  using ECDSA for bytes32;\n\n  constructor() public {\n    //\n  }\n\n  function verifySignature(\n    address _address,\n    bytes32 _messageHash,\n    bytes memory _signature,\n    bool _strict\n  ) public view returns (bool) {\n    return _address.verifySignature(\n      _messageHash.toEthSignedMessageHash(),\n      _signature,\n      _strict\n    );\n  }\n}\n"
    },
    "src/account/AccountProxyV2.sol": {
      "content": "pragma solidity ^0.5.10;\n\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport \"openzeppelin-solidity/contracts/cryptography/ECDSA.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"./AbstractAccount.sol\";\nimport \"./AccountLibrary.sol\";\n\n/**\n * @title Account Proxy V2\n */\ncontract AccountProxyV2 {\n\n  using BytesLib for bytes;\n  using AccountLibrary for AbstractAccount;\n  using ECDSA for bytes32;\n  using SafeMath for uint256;\n\n  bytes4 constant MSG_SIG = bytes4(keccak256(\"forwardAccountOwnerCall(address,uint256,bytes,uint256,address,bytes)\"));\n  bytes4 constant ERC20_TRANSFER = bytes4(keccak256(\"transfer(address,uint256)\"));\n  uint256 constant MAX_CALLS = 5;\n\n  event NewAccountOwnerCall(address account, uint256 nonce);\n\n  struct Account {\n    uint256 nonce;\n  }\n\n  string constant ERR_INVALID_ACCOUNT_NONCE = \"Invalid account nonce\";\n  string constant ERR_INVALID_MESSAGE_SIGNER = \"Invalid message signer\";\n  string constant ERR_CALL_FAILED = \"Call failed\";\n\n  mapping(address => Account) public accounts;\n\n  function forwardAccountOwnerCall(\n    address _account,\n    uint256 _nonce,\n    bytes memory _data,\n    uint256 _refundGas,\n    address _erc20GasToken,\n    bytes memory _signature\n  ) public {\n    bytes[MAX_CALLS] memory _multiData;\n    _multiData[0] = _data;\n\n    _forwardAccountOwnerCall(\n      _account,\n      _nonce,\n      _multiData,\n      1,\n      _refundGas,\n      _erc20GasToken,\n      _signature\n    );\n  }\n\n  function forwardAccountOwnerCalls2(\n    address _account,\n    uint256 _nonce,\n    bytes memory _data1,\n    bytes memory _data2,\n    uint256 _refundGas,\n    address _erc20GasToken,\n    bytes memory _signature\n  ) public {\n    bytes[MAX_CALLS] memory _multiData;\n    _multiData[0] = _data1;\n    _multiData[1] = _data2;\n\n    _forwardAccountOwnerCall(\n      _account,\n      _nonce,\n      _multiData,\n      2,\n      _refundGas,\n      _erc20GasToken,\n      _signature\n    );\n  }\n\n  function forwardAccountOwnerCalls3(\n    address _account,\n    uint256 _nonce,\n    bytes memory _data1,\n    bytes memory _data2,\n    bytes memory _data3,\n    uint256 _refundGas,\n    address _erc20GasToken,\n    bytes memory _signature\n  ) public {\n    bytes[MAX_CALLS] memory _multiData;\n    _multiData[0] = _data1;\n    _multiData[1] = _data2;\n    _multiData[2] = _data3;\n\n    _forwardAccountOwnerCall(\n      _account,\n      _nonce,\n      _multiData,\n      3,\n      _refundGas,\n      _erc20GasToken,\n      _signature\n    );\n  }\n\n  function forwardAccountOwnerCalls4(\n    address _account,\n    uint256 _nonce,\n    bytes memory _data1,\n    bytes memory _data2,\n    bytes memory _data3,\n    bytes memory _data4,\n    uint256 _refundGas,\n    address _erc20GasToken,\n    bytes memory _signature\n  ) public {\n    bytes[MAX_CALLS] memory _multiData;\n    _multiData[0] = _data1;\n    _multiData[1] = _data2;\n    _multiData[2] = _data3;\n    _multiData[3] = _data4;\n\n    _forwardAccountOwnerCall(\n      _account,\n      _nonce,\n      _multiData,\n      4,\n      _refundGas,\n      _erc20GasToken,\n      _signature\n    );\n  }\n\n  function forwardAccountOwnerCalls5(\n    address _account,\n    uint256 _nonce,\n    bytes memory _data1,\n    bytes memory _data2,\n    bytes memory _data3,\n    bytes memory _data4,\n    bytes memory _data5,\n    uint256 _refundGas,\n    address _erc20GasToken,\n    bytes memory _signature\n  ) public {\n    bytes[MAX_CALLS] memory _multiData;\n    _multiData[0] = _data1;\n    _multiData[1] = _data2;\n    _multiData[2] = _data3;\n    _multiData[3] = _data4;\n    _multiData[4] = _data5;\n\n    _forwardAccountOwnerCall(\n      _account,\n      _nonce,\n      _multiData,\n      5,\n      _refundGas,\n      _erc20GasToken,\n      _signature\n    );\n  }\n\n  function _forwardAccountOwnerCall(\n    address _account,\n    uint256 _nonce,\n    bytes[MAX_CALLS] memory _multiData,\n    uint256 _multiDataLen,\n    uint256 _refundGas,\n    address _erc20GasToken,\n    bytes memory _signature\n  ) private {\n    bytes memory _messageData = _multiData[0];\n\n    for (uint256 i = 1; i < _multiDataLen; i++) {\n      _messageData = _messageData.concat(_multiData[i]);\n    }\n\n    bytes32 _messageHash = keccak256(\n      abi.encodePacked(\n        address(this),\n        MSG_SIG,\n        _account,\n        _nonce,\n        _messageData,\n        _refundGas,\n        tx.gasprice,\n        _erc20GasToken\n      )\n    ).toEthSignedMessageHash();\n\n    require(\n      accounts[_account].nonce == _nonce,\n      ERR_INVALID_ACCOUNT_NONCE\n    );\n\n    require(\n      AbstractAccount(_account).verifyOwnerSignature(_messageHash, _signature),\n      ERR_INVALID_MESSAGE_SIGNER\n    );\n\n    accounts[_account].nonce = accounts[_account].nonce.add(1);\n\n    emit NewAccountOwnerCall(_account, _nonce);\n\n    bool _succeeded;\n\n    for (uint256 i = 0; i < _multiDataLen; i++) {\n      (_succeeded,) = _account.call(_multiData[i]);\n\n      require(\n        _succeeded,\n        ERR_CALL_FAILED\n      );\n    }\n\n    if (_refundGas > 0) {\n      if (_erc20GasToken != address(0)){\n        // subtract gas token amount\n        address payable payableReceiver = address(uint160(_erc20GasToken));\n        AbstractAccount(_account).executeTransaction(\n          payableReceiver,\n          0,\n          abi.encodeWithSelector(\n            ERC20_TRANSFER,\n            msg.sender,\n            _refundGas\n          )\n        );\n      } else {\n        // subtract eth gas amount\n        AbstractAccount(_account).executeTransaction(\n          msg.sender,\n          _refundGas.mul(tx.gasprice),\n          new bytes(0)\n        );\n      }\n    }\n  }\n\n}\n"
    },
    "solidity-bytes-utils/contracts/BytesLib.sol": {
      "content": "/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\n\npragma solidity ^0.5.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add \n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes_slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes_slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes_slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes_slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n                \n                for { \n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint _start,\n        uint _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_bytes.length >= (_start + _length));\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\n        require(_bytes.length >= (_start + 20));\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\n        require(_bytes.length >= (_start + 1));\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\n        require(_bytes.length >= (_start + 2));\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\n        require(_bytes.length >= (_start + 4));\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\n        require(_bytes.length >= (_start + 8));\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\n        require(_bytes.length >= (_start + 12));\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\n        require(_bytes.length >= (_start + 16));\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\n        require(_bytes.length >= (_start + 32));\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\n        require(_bytes.length >= (_start + 32));\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes_slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes_slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "src/account/AccountProxyV1.sol": {
      "content": "pragma solidity ^0.5.10;\n\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport \"openzeppelin-solidity/contracts/cryptography/ECDSA.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"./AbstractAccount.sol\";\nimport \"./AccountLibrary.sol\";\n\n/**\n * @title Account Proxy V1\n */\ncontract AccountProxyV1 {\n\n  using BytesLib for bytes;\n  using AccountLibrary for AbstractAccount;\n  using ECDSA for bytes32;\n  using SafeMath for uint256;\n\n  bytes4 constant MSG_SIG = bytes4(keccak256(\"forwardAccountOwnerCall(address,uint256,bytes,uint256,bytes)\"));\n  uint256 constant MAX_CALLS = 5;\n\n  event NewAccountOwnerCall(address account, uint256 nonce);\n\n  struct Account {\n    uint256 nonce;\n  }\n\n  string constant ERR_INVALID_ACCOUNT_NONCE = \"Invalid account nonce\";\n  string constant ERR_INVALID_MESSAGE_SIGNER = \"Invalid message signer\";\n  string constant ERR_CALL_FAILED = \"Call failed\";\n\n  mapping(address => Account) public accounts;\n\n  function forwardAccountOwnerCall(\n    address _account,\n    uint256 _nonce,\n    bytes memory _data,\n    uint256 _refundGas,\n    bytes memory _signature\n  ) public {\n    bytes[MAX_CALLS] memory _multiData;\n    _multiData[0] = _data;\n\n    _forwardAccountOwnerCall(\n      _account,\n      _nonce,\n      _multiData,\n      1,\n      _refundGas,\n      _signature\n    );\n  }\n\n  function forwardAccountOwnerCalls2(\n    address _account,\n    uint256 _nonce,\n    bytes memory _data1,\n    bytes memory _data2,\n    uint256 _refundGas,\n    bytes memory _signature\n  ) public {\n    bytes[MAX_CALLS] memory _multiData;\n    _multiData[0] = _data1;\n    _multiData[1] = _data2;\n\n    _forwardAccountOwnerCall(\n      _account,\n      _nonce,\n      _multiData,\n      2,\n      _refundGas,\n      _signature\n    );\n  }\n\n  function forwardAccountOwnerCalls3(\n    address _account,\n    uint256 _nonce,\n    bytes memory _data1,\n    bytes memory _data2,\n    bytes memory _data3,\n    uint256 _refundGas,\n    bytes memory _signature\n  ) public {\n    bytes[MAX_CALLS] memory _multiData;\n    _multiData[0] = _data1;\n    _multiData[1] = _data2;\n    _multiData[2] = _data3;\n\n    _forwardAccountOwnerCall(\n      _account,\n      _nonce,\n      _multiData,\n      3,\n      _refundGas,\n      _signature\n    );\n  }\n\n  function forwardAccountOwnerCalls4(\n    address _account,\n    uint256 _nonce,\n    bytes memory _data1,\n    bytes memory _data2,\n    bytes memory _data3,\n    bytes memory _data4,\n    uint256 _refundGas,\n    bytes memory _signature\n  ) public {\n    bytes[MAX_CALLS] memory _multiData;\n    _multiData[0] = _data1;\n    _multiData[1] = _data2;\n    _multiData[2] = _data3;\n    _multiData[3] = _data4;\n\n    _forwardAccountOwnerCall(\n      _account,\n      _nonce,\n      _multiData,\n      4,\n      _refundGas,\n      _signature\n    );\n  }\n\n  function forwardAccountOwnerCalls5(\n    address _account,\n    uint256 _nonce,\n    bytes memory _data1,\n    bytes memory _data2,\n    bytes memory _data3,\n    bytes memory _data4,\n    bytes memory _data5,\n    uint256 _refundGas,\n    bytes memory _signature\n  ) public {\n    bytes[MAX_CALLS] memory _multiData;\n    _multiData[0] = _data1;\n    _multiData[1] = _data2;\n    _multiData[2] = _data3;\n    _multiData[3] = _data4;\n    _multiData[4] = _data5;\n\n    _forwardAccountOwnerCall(\n      _account,\n      _nonce,\n      _multiData,\n      5,\n      _refundGas,\n      _signature\n    );\n  }\n\n  function _forwardAccountOwnerCall(\n    address _account,\n    uint256 _nonce,\n    bytes[MAX_CALLS] memory _multiData,\n    uint256 _multiDataLen,\n    uint256 _refundGas,\n    bytes memory _signature\n  ) private {\n    bytes memory _messageData = _multiData[0];\n\n    for (uint256 i = 1; i < _multiDataLen; i++) {\n      _messageData = _messageData.concat(_multiData[i]);\n    }\n\n    bytes32 _messageHash = keccak256(\n      abi.encodePacked(\n        address(this),\n        MSG_SIG,\n        _account,\n        _nonce,\n        _messageData,\n        _refundGas,\n        tx.gasprice\n      )\n    ).toEthSignedMessageHash();\n\n    require(\n      accounts[_account].nonce == _nonce,\n      ERR_INVALID_ACCOUNT_NONCE\n    );\n\n    require(\n      AbstractAccount(_account).verifyOwnerSignature(_messageHash, _signature),\n      ERR_INVALID_MESSAGE_SIGNER\n    );\n\n    accounts[_account].nonce = accounts[_account].nonce.add(1);\n\n    emit NewAccountOwnerCall(_account, _nonce);\n\n    bool _succeeded;\n\n    for (uint256 i = 0; i < _multiDataLen; i++) {\n      (_succeeded,) = _account.call(_multiData[i]);\n\n      require(\n        _succeeded,\n        ERR_CALL_FAILED\n      );\n    }\n\n\n    if (_refundGas > 0) {\n      AbstractAccount(_account).executeTransaction(\n        msg.sender,\n        _refundGas.mul(tx.gasprice),\n        new bytes(0)\n      );\n    }\n  }\n\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC721/ERC721.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../introspection/ERC165.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721 is ERC165, IERC721 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from token ID to owner\n    mapping (uint256 => address) private _tokenOwner;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping (address => uint256) private _ownedTokensCount;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n    /*\n     * 0x80ac58cd ===\n     *     bytes4(keccak256('balanceOf(address)')) ^\n     *     bytes4(keccak256('ownerOf(uint256)')) ^\n     *     bytes4(keccak256('approve(address,uint256)')) ^\n     *     bytes4(keccak256('getApproved(uint256)')) ^\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n     */\n\n    constructor () public {\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n    }\n\n    /**\n     * @dev Gets the balance of the specified address\n     * @param owner address to query the balance of\n     * @return uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0));\n        return _ownedTokensCount[owner];\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return owner address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _tokenOwner[tokenId];\n        require(owner != address(0));\n        return owner;\n    }\n\n    /**\n     * @dev Approves another address to transfer the given token ID\n     * The zero address indicates there is no approved address.\n     * There can only be one approved address per token at a given time.\n     * Can only be called by the token owner or an approved operator.\n     * @param to address to be approved for the given token ID\n     * @param tokenId uint256 ID of the token to be approved\n     */\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner);\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Gets the approved address for a token ID, or zero if no address set\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to query the approval of\n     * @return address currently approved for the given token ID\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_exists(tokenId));\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator\n     * An operator is allowed to transfer all tokens of the sender on their behalf\n     * @param to operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address to, bool approved) public {\n        require(to != msg.sender);\n        _operatorApprovals[msg.sender][to] = approved;\n        emit ApprovalForAll(msg.sender, to, approved);\n    }\n\n    /**\n     * @dev Tells whether an operator is approved by a given owner\n     * @param owner owner address which you want to query the approval of\n     * @param operator operator address which you want to query the approval of\n     * @return bool whether the given operator is approved by the given owner\n     */\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Transfers the ownership of a given token ID to another address\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n     * Requires the msg sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n    */\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId));\n\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     *\n     * Requires the msg sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n    */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n        transferFrom(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data));\n    }\n\n    /**\n     * @dev Returns whether the specified token exists\n     * @param tokenId uint256 ID of the token to query the existence of\n     * @return whether the token exists\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner = _tokenOwner[tokenId];\n        return owner != address(0);\n    }\n\n    /**\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Internal function to mint a new token\n     * Reverts if the given token ID already exists\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0));\n        require(!_exists(tokenId));\n\n        _tokenOwner[tokenId] = to;\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * Reverts if the token does not exist\n     * Deprecated, use _burn(uint256) instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == owner);\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[owner] = _ownedTokensCount[owner].sub(1);\n        _tokenOwner[tokenId] = address(0);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * Reverts if the token does not exist\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(uint256 tokenId) internal {\n        _burn(ownerOf(tokenId), tokenId);\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n    */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from);\n        require(to != address(0));\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n\n        _tokenOwner[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke `onERC721Received` on a target address\n     * The call is not executed if the target address is not a contract\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Private function to clear current approval of a given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _clearApproval(uint256 tokenId) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC721/IERC721.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic interface\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function balanceOf(address owner) public view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     * after a `safeTransfer`. This function MUST return the function selector,\n     * otherwise the caller will revert the transaction. The selector to be\n     * returned can be obtained as `this.onERC721Received.selector`. This\n     * function MAY throw to revert and reject the transfer.\n     * Note: the ERC721 contract address is always the message sender.\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n    public returns (bytes4);\n}\n"
    },
    "openzeppelin-solidity/contracts/introspection/ERC165.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @title ERC165\n * @author Matt Condon (@shrugs)\n * @dev Implements ERC165 using a lookup table.\n */\ncontract ERC165 is IERC165 {\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n    /**\n     * 0x01ffc9a7 ===\n     *     bytes4(keccak256('supportsInterface(bytes4)'))\n     */\n\n    /**\n     * @dev a mapping of interface id to whether or not it's supported\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    /**\n     * @dev A contract implementing SupportsInterfaceWithLookup\n     * implement ERC165 itself\n     */\n    constructor () internal {\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev implement supportsInterface(bytes4) using a lookup table\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev internal method for registering an interface\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff);\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/introspection/IERC165.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title IERC165\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n */\ninterface IERC165 {\n    /**\n     * @notice Query if a contract implements an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @dev Interface identification is specified in ERC-165. This function\n     * uses less than 30,000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/example/ERC721ExampleToken.sol": {
      "content": "pragma solidity ^0.5.10;\n\nimport \"openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\";\n\n\n/**\n * @title ERC721 example token\n */\ncontract ERC721ExampleToken is ERC721 {\n  constructor() public {\n    //\n  }\n\n  function mint(uint256 tokenId) public returns (bool) {\n    _mint(msg.sender, tokenId);\n    return true;\n  }\n\n  function mintTo(address to, uint256 tokenId) public returns (bool) {\n    _mint(to, tokenId);\n    return true;\n  }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n * Originally based on code by FirstBlood:\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n *\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\n * compliant implementations may not do it.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowed;\n\n    uint256 private _totalSupply;\n\n    /**\n    * @dev Total number of tokens in existence\n    */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param owner The address to query the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    /**\n    * @dev Transfer token for a specified address\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another.\n     * Note that while this function emits an Approval event, this is not required as per the specification,\n     * and other compliant implementations may not emit the event.\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n    * @dev Transfer token for a specified addresses\n    * @param from The address to transfer from.\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Internal function that mints an amount of the token and assigns it to\n     * an account. This encapsulates the modification of balances such that the\n     * proper events are emitted.\n     * @param account The account that will receive the created tokens.\n     * @param value The amount that will be created.\n     */\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account.\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account, deducting from the sender's allowance for said account. Uses the\n     * internal burn function.\n     * Emits an Approval event (reflecting the reduced allowance).\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "src/example/ERC20ExampleToken.sol": {
      "content": "pragma solidity ^0.5.10;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\n\n\n/**\n * @title ERC20 example token\n */\ncontract ERC20ExampleToken is ERC20 {\n  constructor() public {\n    //\n  }\n\n  function mint(uint256 amount) public returns (bool) {\n    _mint(msg.sender, amount);\n    return true;\n  }\n\n  function mintTo(address to, uint256 amount) public returns (bool) {\n    _mint(to, amount);\n    return true;\n  }\n}\n"
    },
    "src/account/AccountProviderV2.sol": {
      "content": "pragma solidity ^0.5.10;\n\nimport \"openzeppelin-solidity/contracts/cryptography/ECDSA.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"../contractCreator/ContractCreator.sol\";\nimport \"../ens/ENSMultiManager.sol\";\nimport \"../guardian/Guarded.sol\";\nimport \"./AbstractAccount.sol\";\nimport \"./AccountLibrary.sol\";\n\n/**\n * @title Account Provider V2\n */\ncontract AccountProviderV2 is ContractCreator, ENSMultiManager, Guarded {\n\n  using AccountLibrary for address;\n  using ECDSA for bytes32;\n  using SafeMath for uint256;\n\n  event AccountCreated(address account);\n  event AccountEnsNameUpdated(address account);\n\n  bytes1 constant ACCOUNT_SALT_MSG_PREFIX = 0x01;\n  bytes1 constant ACCOUNT_SALT_MSG_PREFIX_UNSAFE = 0x02;\n  string constant ERR_INVALID_SIGNATURE = \"Invalid signature\";\n\n  address private accountProxy;\n\n  constructor(\n    address _guardian,\n    bytes memory _accountContractCode,\n    address _accountProxy,\n    address _ens\n  ) ContractCreator(_accountContractCode) ENSMultiManager(_ens) Guarded(_guardian) public {\n    accountProxy = _accountProxy;\n  }\n\n  function updateAccountEnsName(\n    bytes32 _ensLabel,\n    bytes32 _ensNode,\n    bytes  memory _guardianSignature\n  ) public {\n    bytes32 _messageHash = keccak256(\n      abi.encodePacked(\n        address(this),\n        msg.sig,\n        _ensLabel,\n        _ensNode,\n        msg.sender\n      )\n    ).toEthSignedMessageHash();\n\n    require(\n      guardian.verifySignature(_messageHash, _guardianSignature, true),\n      ERR_INVALID_SIGNATURE\n    );\n\n    _register(\n      _ensLabel,\n      _ensNode,\n      msg.sender\n    );\n\n    emit AccountEnsNameUpdated(msg.sender);\n  }\n\n  function createAccount(\n    bytes32 _ensLabel,\n    bytes32 _ensNode,\n    uint256 _refundGas,\n    bytes memory _signature\n  ) onlyGuardian public {\n    address _device = keccak256(\n      abi.encodePacked(\n        address(this),\n        msg.sig,\n        _ensLabel,\n        _ensNode,\n        _refundGas,\n        tx.gasprice\n      )\n    ).toEthSignedMessageHash().recover(_signature);\n\n    bytes32 _salt = keccak256(abi.encodePacked(\n        ACCOUNT_SALT_MSG_PREFIX,\n        keccak256(abi.encodePacked(_device))\n      ));\n\n    address _account = _createAccount(\n      _salt,\n      _device,\n      _refundGas\n    );\n\n    if (_ensLabel != 0) {\n      _register(\n        _ensLabel,\n        _ensNode,\n        _account\n      );\n    }\n  }\n\n  function unsafeCreateAccount(\n    uint256 _accountId,\n    address _device,\n    bytes32 _ensLabel,\n    bytes32 _ensNode,\n    uint256 _refundGas\n  ) onlyGuardian public {\n    bytes32 _salt = keccak256(\n      abi.encodePacked(\n        ACCOUNT_SALT_MSG_PREFIX_UNSAFE,\n        _accountId\n      )\n    );\n\n    address _account = _createAccount(\n      _salt,\n      _device,\n      _refundGas\n    );\n\n    if (_ensLabel != 0) {\n      _register(\n        _ensLabel,\n        _ensNode,\n        _account\n      );\n    }\n  }\n\n  function _createAccount(\n    bytes32 _salt,\n    address _device,\n    uint256 _refundGas\n  ) private returns (address) {\n    // initialize account\n    AbstractAccount _account = AbstractAccount(_createContract(_salt));\n\n    if (_refundGas > 0) {\n      // subtract eth gas amount\n      _account.executeTransaction(\n        msg.sender,\n        _refundGas.mul(tx.gasprice),\n        new bytes(0)\n      );\n    }\n\n    _account.addDevice(_device, true);\n    _account.addDevice(accountProxy, true);\n    _account.removeDevice(address(this));\n\n    emit AccountCreated(address(_account));\n\n    return address(_account);\n  }\n\n  function changeAccountProxy(address _accountProxy) onlyGuardian public {\n    accountProxy = _accountProxy;\n  }\n}\n"
    },
    "src/contractCreator/ContractCreator.sol": {
      "content": "pragma solidity ^0.5.10;\n\n/**\n * @title Contract Creator\n */\ncontract ContractCreator {\n\n  bytes private contractCode;\n  bytes32 private contractCodeHash;\n\n  constructor(bytes memory _contractCode) internal {\n    contractCode = _contractCode;\n    contractCodeHash = keccak256(_contractCode);\n  }\n\n  function _createContract(bytes32 _salt) internal returns (address _contract) {\n    bytes memory _contractCode = contractCode;\n\n    assembly {\n      let p := add(_contractCode, 0x20)\n      let n := mload(_contractCode)\n      _contract := create2(0, p, n, _salt)\n      if iszero(extcodesize(_contract)) {revert(0, 0)}\n    }\n  }\n\n  function _computeContractAddress(bytes32 _salt) internal view returns (address _contractAddress) {\n    bytes32 _data = keccak256(\n      abi.encodePacked(\n        bytes1(0xff),\n        address(this),\n        _salt,\n        contractCodeHash\n      )\n    );\n\n    _contractAddress = address(bytes20(_data << 96));\n  }\n}\n"
    },
    "src/ens/ENSMultiManager.sol": {
      "content": "pragma solidity ^0.5.10;\n\nimport \"@ensdomains/ens/contracts/ENS.sol\";\nimport \"./AbstractENSAddrResolver.sol\";\n\n\n/**\n * @title ENS Multi Manager\n */\ncontract ENSMultiManager is AbstractENSAddrResolver {\n  event DebugAddr(address value);\n  event DebugBytes32(bytes32 value);\n\n  event EnsRootNodeAdded(bytes32 rootNode, address owner);\n  event EnsRootNodeVerified(bytes32 rootNode);\n  event EnsRootNodeReleased(bytes32 rootNode);\n\n  struct EnsRootNode {\n    address owner;\n    bool verified;\n  }\n\n  string constant ERR_ONLY_NODE_OWNER = \"Sender is not ENS node owner\";\n  string constant ERR_LABEL_ALREADY_TAKEN = \"ENS label already taken\";\n  string constant ERR_ROOT_NODE_NOT_VERIFIED = \"ENS root node not verified\";\n  string constant ERR_ROOT_NODE_DOESNT_EXIST = \"ENS root node doesn't exist\";\n\n  mapping(bytes32 => EnsRootNode) public ensRootNodes;\n  mapping(bytes32 => address) private ensNodeAddresses;\n\n  ENS private ens;\n\n  constructor(address _ens) internal {\n    ens = ENS(_ens);\n  }\n\n  function addr(bytes32 _node) public view returns (address) {\n    return ensNodeAddresses[_node];\n  }\n\n  function setAddr(bytes32 _node, address _addr) public {\n    require(\n      ensNodeAddresses[_node] == msg.sender,\n      ERR_ONLY_NODE_OWNER\n    );\n\n    ensNodeAddresses[_node] = _addr;\n\n    emit AddrChanged(_node, _addr);\n  }\n\n  function addEnsRootNode(bytes32 _rootNode) public {\n    require(\n      ens.owner(_rootNode) == msg.sender,\n      ERR_ONLY_NODE_OWNER\n    );\n\n    ensRootNodes[_rootNode].owner = msg.sender;\n\n    emit EnsRootNodeAdded(_rootNode, msg.sender);\n  }\n\n  function verifyEnsRootNode(bytes32 _rootNode) public {\n    require(\n      ens.owner(_rootNode) == address(this),\n      ERR_ROOT_NODE_NOT_VERIFIED\n    );\n\n    ensRootNodes[_rootNode].verified = true;\n\n    emit EnsRootNodeVerified(_rootNode);\n  }\n\n  function releaseEnsRootNode(bytes32 _rootNode) public {\n    require(\n      ensRootNodes[_rootNode].owner == msg.sender,\n      ERR_ONLY_NODE_OWNER\n    );\n\n    if (ensRootNodes[_rootNode].verified) {\n      ens.setOwner(_rootNode, msg.sender);\n    }\n\n    delete ensRootNodes[_rootNode];\n\n    emit EnsRootNodeReleased(_rootNode);\n  }\n\n  function _register(bytes32 _label, bytes32 _rootNode, address _addr) internal {\n    require(\n      ensRootNodes[_rootNode].owner != address(0),\n      ERR_ROOT_NODE_DOESNT_EXIST\n    );\n    require(\n      ensRootNodes[_rootNode].verified,\n      ERR_ROOT_NODE_NOT_VERIFIED\n    );\n\n    bytes32 _node = keccak256(abi.encodePacked(_rootNode, _label));\n\n    require(\n      ensNodeAddresses[_node] == address(0),\n      ERR_LABEL_ALREADY_TAKEN\n    );\n\n    ensNodeAddresses[_node] = _addr;\n\n    bytes memory data = abi.encodeWithSelector(\n      ens.setSubnodeOwner.selector,\n      _rootNode,\n      _label,\n      address(this)\n    );\n\n    (bool _succeeded, ) = address(ens).call(data);\n\n    require(\n      _succeeded,\n      \"Reverted ens.setSubnodeOwner\"\n    );\n\n    ens.setResolver(_node, address(this));\n    ens.setOwner(_node, _addr);\n  }\n}\n"
    },
    "src/guardian/Guarded.sol": {
      "content": "pragma solidity ^0.5.10;\n\nimport \"../account/AbstractAccount.sol\";\nimport \"../account/AccountLibrary.sol\";\n\n\n/**\n * @title Guarded\n */\ncontract Guarded {\n\n  using AccountLibrary for AbstractAccount;\n\n  string constant ERR_ONLY_GUARDIAN = \"Sender is not a guardian or guardian device\";\n\n  AbstractAccount public guardian;\n\n  modifier onlyGuardian() {\n    require(\n      (\n      address(guardian) == msg.sender ||\n      guardian.isAnyDevice(msg.sender)\n      ),\n      ERR_ONLY_GUARDIAN\n    );\n\n    _;\n  }\n\n  constructor(address _guardian) internal {\n    guardian = AbstractAccount(_guardian);\n  }\n}\n"
    },
    "@ensdomains/ens/contracts/ENS.sol": {
      "content": "pragma solidity >=0.4.24;\n\ninterface ENS {\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external;\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external;\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns(bytes32);\n    function setResolver(bytes32 node, address resolver) external;\n    function setOwner(bytes32 node, address owner) external;\n    function setTTL(bytes32 node, uint64 ttl) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function owner(bytes32 node) external view returns (address);\n    function resolver(bytes32 node) external view returns (address);\n    function ttl(bytes32 node) external view returns (uint64);\n    function recordExists(bytes32 node) external view returns (bool);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "src/ens/AbstractENSAddrResolver.sol": {
      "content": "pragma solidity ^0.5.10;\n\n/**\n * @title Abstract ENS Addr Resolver\n */\ncontract AbstractENSAddrResolver {\n\n  event AddrChanged(bytes32 indexed node, address addr);\n\n  function addr(bytes32 _node) public view returns (address);\n\n  function setAddr(bytes32 _node, address _addr) public;\n}\n"
    },
    "src/account/AccountProviderV1.sol": {
      "content": "pragma solidity ^0.5.10;\n\nimport \"openzeppelin-solidity/contracts/cryptography/ECDSA.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"../contractCreator/ContractCreator.sol\";\nimport \"../ens/ENSMultiManager.sol\";\nimport \"../guardian/Guarded.sol\";\nimport \"./AbstractAccount.sol\";\nimport \"./AccountLibrary.sol\";\n\n\n/**\n * @title Account Provider V1\n */\ncontract AccountProviderV1 is ContractCreator, ENSMultiManager, Guarded {\n\n  using AccountLibrary for address;\n  using ECDSA for bytes32;\n  using SafeMath for uint256;\n\n  event AccountCreated(address account);\n  event AccountEnsNameUpdated(address account);\n\n  bytes1 constant ACCOUNT_SALT_MSG_PREFIX = 0x01;\n  bytes1 constant ACCOUNT_SALT_MSG_PREFIX_UNSAFE = 0x02;\n  string constant ERR_INVALID_SIGNATURE = \"Invalid signature\";\n\n  address private accountProxy;\n\n  constructor(\n    address _guardian,\n    bytes memory _accountContractCode,\n    address _accountProxy,\n    address _ens\n  ) ContractCreator(_accountContractCode) ENSMultiManager(_ens) Guarded(_guardian) public {\n    accountProxy = _accountProxy;\n  }\n\n  function updateAccountEnsName(\n    bytes32 _ensLabel,\n    bytes32 _ensNode,\n    bytes  memory _guardianSignature\n  ) public {\n    bytes32 _messageHash = keccak256(\n      abi.encodePacked(\n        address(this),\n        msg.sig,\n        _ensLabel,\n        _ensNode,\n        msg.sender\n      )\n    ).toEthSignedMessageHash();\n\n    require(\n      guardian.verifySignature(_messageHash, _guardianSignature, true),\n      ERR_INVALID_SIGNATURE\n    );\n\n    _register(\n      _ensLabel,\n      _ensNode,\n      msg.sender\n    );\n\n    emit AccountEnsNameUpdated(msg.sender);\n  }\n\n  function createAccount(\n    bytes32 _ensLabel,\n    bytes32 _ensNode,\n    uint256 _refundGas,\n    bytes memory _signature\n  ) onlyGuardian public {\n    address _device = keccak256(\n      abi.encodePacked(\n        address(this),\n        msg.sig,\n        _ensLabel,\n        _ensNode,\n        _refundGas,\n        tx.gasprice\n      )\n    ).toEthSignedMessageHash().recover(_signature);\n\n    bytes32 _salt = keccak256(abi.encodePacked(\n        ACCOUNT_SALT_MSG_PREFIX,\n        keccak256(abi.encodePacked(_device))\n      ));\n\n    address _account = _createAccount(\n      _salt,\n      _device,\n      _refundGas\n    );\n\n    if (_ensLabel != 0) {\n      _register(\n        _ensLabel,\n        _ensNode,\n        _account\n      );\n    }\n  }\n\n  function unsafeCreateAccount(\n    uint256 _accountId,\n    address _device,\n    bytes32 _ensLabel,\n    bytes32 _ensNode,\n    uint256 _refundGas\n  ) onlyGuardian public {\n    bytes32 _salt = keccak256(\n      abi.encodePacked(\n        ACCOUNT_SALT_MSG_PREFIX_UNSAFE,\n        _accountId\n      )\n    );\n\n    address _account = _createAccount(\n      _salt,\n      _device,\n      _refundGas\n    );\n\n    if (_ensLabel != 0) {\n      _register(\n        _ensLabel,\n        _ensNode,\n        _account\n      );\n    }\n  }\n\n  function _createAccount(\n    bytes32 _salt,\n    address _device,\n    uint256 _refundGas\n  ) private returns (address) {\n    // initialize account\n    AbstractAccount _account = AbstractAccount(_createContract(_salt));\n\n    if (_refundGas > 0) {\n      _account.executeTransaction(\n        msg.sender,\n        _refundGas.mul(tx.gasprice),\n        new bytes(0)\n      );\n    }\n\n    _account.addDevice(_device, true);\n    _account.addDevice(accountProxy, true);\n    _account.removeDevice(address(this));\n\n    emit AccountCreated(address(_account));\n\n    return address(_account);\n  }\n}\n"
    },
    "src/ens/ENSMultiManagerWrapper.sol": {
      "content": "pragma solidity ^0.5.10;\n\nimport \"./ENSMultiManager.sol\";\n\n\n/**\n * @title ENS Multi Manager Wrapper\n */\ncontract ENSMultiManagerWrapper is ENSMultiManager {\n\n  event Registered(bytes32 label, bytes32 rootNode, address addr);\n\n  constructor(address _ens) public ENSMultiManager(_ens) {\n    //\n  }\n\n  function register(bytes32 _label, bytes32 _rootNode, address _addr) public {\n    _register(_label, _rootNode, _addr);\n\n    emit Registered(_label, _rootNode, _addr);\n  }\n}\n"
    },
    "src/account/AccountFriendRecovery.sol": {
      "content": "pragma solidity ^0.5.10;\n\nimport \"openzeppelin-solidity/contracts/cryptography/ECDSA.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport \"./AbstractAccount.sol\";\nimport \"./AccountLibrary.sol\";\n\n\n/**\n * @title Account Friend Recovery\n */\ncontract AccountFriendRecovery {\n\n  event RequiredFriendsChanged(address account, uint256 requiredFriends);\n  event FriendsChanged(address account, address[] friends);\n\n  using AccountLibrary for AbstractAccount;\n  using ECDSA for bytes32;\n  using SafeMath for uint256;\n  using BytesLib for bytes;\n\n  struct Account {\n    uint256 nonce;\n    uint256 requiredFriends;\n    address[] friends;\n    mapping(address => bool) friendsMap;\n  }\n\n  mapping(address => Account) public accounts;\n\n  modifier onlyConnectedAccount() {\n    require(\n      AbstractAccount(msg.sender).isOwnerDevice(address(this))\n    );\n\n    _;\n  }\n\n  function setup(uint256 _requiredFriends, address[] memory _friends) onlyConnectedAccount public {\n    _setRequiredFriends(_requiredFriends);\n    _setFriends(_friends);\n  }\n\n  function setRequiredFriends(uint256 _requiredFriends) onlyConnectedAccount public {\n    _setRequiredFriends(_requiredFriends);\n  }\n\n  function setFriends(address[] memory _friends) onlyConnectedAccount public {\n    _setFriends(_friends);\n  }\n\n  function recoverAccount(\n    address _account,\n    address _device,\n    address[] memory _friends,\n    bytes memory _signatures,\n    uint256 _gasFee\n  ) public {\n    uint friendsLength = _friends.length;\n    uint signaturesLength = _signatures.length;\n\n    require(\n      accounts[_account].requiredFriends > 0 &&\n      accounts[_account].requiredFriends == friendsLength &&\n      signaturesLength == friendsLength * 65\n    );\n\n    bytes32 _messageHash = keccak256(\n      abi.encodePacked(\n        address(this),\n        msg.sig,\n        _account,\n        _device,\n        accounts[_account].nonce,\n        _gasFee,\n        tx.gasprice\n      )\n    ).toEthSignedMessageHash();\n\n    for (uint i = 0; i < friendsLength; i++) {\n      bytes memory signature = _signatures.slice(i * 65, 65);\n\n      require(\n        accounts[_account].friendsMap[_friends[i]] &&\n        AbstractAccount(_friends[i]).verifyOwnerSignature(_messageHash, signature)\n      );\n\n      for (uint j = 0; j < friendsLength; j++) {\n        if (j != i) {\n          require(_friends[i] != _friends[j]);\n        }\n      }\n    }\n\n    accounts[_account].nonce = accounts[_account].nonce.add(1);\n\n    AbstractAccount(_account).addDevice(_device, true);\n\n    if (_gasFee > 0) {\n      AbstractAccount(_account).executeTransaction(\n        msg.sender,\n        _gasFee.mul(tx.gasprice),\n        new bytes(0)\n      );\n    }\n  }\n\n  function _setRequiredFriends(uint256 _requiredFriends) private {\n    accounts[msg.sender].requiredFriends = _requiredFriends;\n\n    emit RequiredFriendsChanged(msg.sender, _requiredFriends);\n  }\n\n  function _setFriends(address[] memory _friends) private {\n    uint friendsLength = accounts[msg.sender].friends.length;\n    uint i;\n\n    for (i = 0; i < friendsLength; i++) {\n      delete accounts[msg.sender].friendsMap[accounts[msg.sender].friends[i]];\n    }\n\n    accounts[msg.sender].friends = _friends;\n\n    friendsLength = _friends.length;\n\n    for (i = 0; i < friendsLength; i++) {\n      require(\n        !accounts[msg.sender].friendsMap[_friends[i]] && _friends[i] != address(0)\n      );\n\n      accounts[msg.sender].friendsMap[_friends[i]] = true;\n    }\n\n    emit FriendsChanged(msg.sender, _friends);\n  }\n}\n"
    },
    "src/account/Account.sol": {
      "content": "pragma solidity ^0.5.10;\n\nimport \"./AbstractAccount.sol\";\n\n\n/**\n * @title Account\n */\ncontract Account is AbstractAccount {\n\n  modifier onlyOwner() {\n    require(\n      devices[msg.sender].isOwner\n    );\n\n    _;\n  }\n\n  constructor() public {\n    devices[msg.sender].isOwner = true;\n    devices[msg.sender].exists = true;\n    devices[msg.sender].existed = true;\n  }\n\n  function() external payable {\n    //\n  }\n\n  function addDevice(address _device, bool _isOwner) onlyOwner public {\n    require(\n      _device != address(0)\n    );\n    require(\n      !devices[_device].exists\n    );\n\n    devices[_device].isOwner = _isOwner;\n    devices[_device].exists = true;\n    devices[_device].existed = true;\n\n    emit DeviceAdded(_device, _isOwner);\n  }\n\n  function removeDevice(address _device) onlyOwner public {\n    require(\n      devices[_device].exists\n    );\n\n    devices[_device].isOwner = false;\n    devices[_device].exists = false;\n\n    emit DeviceRemoved(_device);\n  }\n\n  function executeTransaction(address payable _recipient, uint256 _value, bytes memory _data) onlyOwner public returns (bytes memory _response) {\n    require(\n      _recipient != address(0)\n    );\n\n    bool _succeeded;\n    (_succeeded, _response) = _recipient.call.value(_value)(_data);\n\n    require(\n      _succeeded\n    );\n\n    emit TransactionExecuted(_recipient, _value, _data, _response);\n  }\n\n  function isValidSignature(\n    bytes memory _data,\n    bytes memory _signature\n  ) public view returns (bytes4 magicValue) {\n    address _recovered;\n\n    if (_signature.length == 65) {\n      bytes32 _r;\n      bytes32 _s;\n      uint8 _v;\n\n      assembly {\n        _r := mload(add(_signature, 0x20))\n        _s := mload(add(_signature, 0x40))\n        _v := byte(0, mload(add(_signature, 0x60)))\n      }\n\n      if (_v < 27) {\n        _v += 27;\n      }\n\n      if (_v == 27 || _v == 28) {\n        _recovered = ecrecover(\n          keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", uint2str(_data.length), _data)),\n          _v,\n          _r,\n          _s\n        );\n      }\n    }\n\n    if (devices[_recovered].existed) {\n      magicValue = 0x20c13b0b;\n    } else {\n      magicValue = 0xffffffff;\n    }\n  }\n\n  function uint2str(uint _num) internal pure returns (string memory _uintAsString) {\n    if (_num == 0) {\n      return \"0\";\n    }\n    uint i = _num;\n    uint j = _num;\n    uint len;\n    while (j != 0) {\n      len++;\n      j /= 10;\n    }\n    bytes memory bstr = new bytes(len);\n    uint k = len - 1;\n    while (i != 0) {\n      bstr[k--] = byte(uint8(48 + i % 10));\n      i /= 10;\n    }\n    return string(bstr);\n  }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "istanbul",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}